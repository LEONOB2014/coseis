#!/bin/bash -e

echo "SORD setup"

# Get command line options
mode=guess
optimize=O
setup=yes
run=
while getopts spibqgGnm:df opt; do
case "$opt" in
  s) mode=s ;;
  p) mode=p ;;
  i) run=i ;;
  b) run=b ;;
  q) run=q ;;
  g) optimize=g ;;
  G) optimize=g; run=g ;;
  n) setup= ; run= ;;
  m) machine="$OPTARG" ;;
  d) rm -rf out/* ;;
  f) rm -rf tmp ;;
  *) exit ;;
esac
done
shift $(( OPTIND - 1 ))

# Symlink input file specified on command line
if [ "$1" ]; then 
  infile="$1"
  [ -f "$infile" ] || exit
  ln -sf "$infile" 'in.m'
else
  infile=$( readlink 'in.m' 2> /dev/null ) || infile='in.m'
fi
mkdir -p tmp

# Locations
srcdir=$( /bin/pwd )
count=$( echo out/[0-9][0-9] | sed 's/.*\///' )
[ "$count" = '[0-9][0-9]' ] && count=00
count=$( echo $count | awk '{ printf "%02d", $1+1 }' )

# Prepare input file
cat 'defaults.m' 'in.m' | sed "
s/%.*$//;
s/;/\\
/g;
" | sed "
s/[]{}='	[]/ /g;
s/  */ /g;
s/^ //;
s/ $//;
/^$/d
" > tmp/input

# Read input
nout=0
while read key params; do
set -- $params
case "$key" in
  nt)  nt=$1 ;;
  nn)  nm3=( $1 $2 $3 ) ;;
  np)  np3=( $1 $2 $3 ) ;;
  out) nout=$(( nout + 1 )) ;;
  timeseries) nout=$(( nout + 1 )) ;;
  datadir) datadir="$1" ;;
  return) break ;;
esac
done < tmp/input

[ "$run" -a "$run" != q ] && interactive=yes

# Host
if [ "$machine" ]; then :
elif [ "${HOSTNAME:0:2}" = ds ]; then machine=datastar
elif [ "${HOSTNAME:0:2}" = tg ]; then machine=teragrid
elif [ "$HOSTNAME" = master ];   then machine=babieca
else machine=$HOSTNAME
fi

# Machine attributes
maxnodes=1; maxcpus=1; maxram=800; rate=200
case $machine in
  wide)                   maxcpus=2; maxram=1800 ;;
  phim)                              maxram=2800;  rate=200 ;;
  altai)                  maxcpus=8; maxram=30000; rate=90  ;; 
  babieca)  maxnodes=36;  maxcpus=2; maxram=800;   rate=160 ;;
  teragrid) maxnodes=252; maxcpus=2; maxram=3000;  rate=500 ;;
  datastar) maxnodes=265; maxcpus=8; maxram=13500 ;;          
esac
echo "Machine: $machine"
echo "CPUs: $(( maxnodes * maxcpus ))"

# Number of processors
[ $mode = guess -a $(( maxnodes * maxcpus )) -eq 1 ] && mode=s
[ $mode = s ] && np3=( 1 1 1 )
np=$(( np3[0] * np3[1] * np3[2] ));
[ $mode = guess -a $np -eq 1 ] && mode=s
[ $mode = guess -a $np -gt 1 ] && mode=p
nodes=$(( np / maxcpus + ( np % maxcpus > 0 ? 1 : 0 ) ))
[ $nodes -gt $maxnodes ] && nodes=$maxnodes
ppn=$(( np / nodes + ( np % nodes > 0 ? 1 : 0 ) ))
cpus=$ppn
[ $cpus -gt $maxcpus ] && cpus=$maxcpus

# Domain size
nm3[0]=$(( nm3[0] / np3[0] + 2 + ( nm3[0] % np3[0] > 0 ? 1 : 0 ) ))
nm3[1]=$(( nm3[1] / np3[1] + 2 + ( nm3[1] % np3[1] > 0 ? 1 : 0 ) ))
nm3[2]=$(( nm3[2] / np3[2] + 2 + ( nm3[2] % np3[2] > 0 ? 1 : 0 ) ))
nm=$( echo ${nm3[*]} | awk '{ print $1 * $2 * $3 }' )

# RAM and Wall time usage
floatsize=4
nvars=24
ram=$( echo $ppn $nm $nvars $floatsize | awk '{ printf "%.0f", $1 * ( $2 * $3 * $4 / 1024 / 1024 + 15 ) }' )
mm=$(  echo $nt $ppn $nm $cpus $rate | awk '{ printf "%.0f", ( $1 + 2 ) * $2 * $3 / $4 / $5 / 40000 + 10 }' )
sus=$( echo $nt $ppn $nm $cpus $rate $nodes $maxcpus | awk '{ printf "%.0f", ( $1 + 2 ) * $2 * $3 / $4 / $5 / 3600000 * $6 * $7 }' )
hh=$(( mm / 60 ))
mm=$(( mm % 60 ))
walltime=$( echo $hh $mm | awk '{ printf "%d:%02d:00", $1, $2 }' )
echo "Processes: $np"
echo "Memory usage: ${ram}Mb per node"
echo "Wall time limit: $walltime"
echo "SUs: $sus"
[ $ppn -gt $maxcpus ] && echo "Warning: exceding available CPUs per node ($maxcpus)"
[ $ram -gt $maxram ]  && echo "Warning: exceding available RAM per node (${maxram}Mb)"

[ "$setup" ] || exit

#------------------------------------------------------------------------------#

# Compiler
IFS=":$IFS"
for dir in $PATH; do
for file in xlf95_r ifort pgf90 gfortran f95; do
  if [ -x $dir/$file ]; then
    sfc=$file
    break 2
  fi
done
done
pfc='mpif90'
case $sfc in
xlf95_r)
  sfc='xlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg'
  pfc='mpxlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg'
  gflags='-p -g -C -qflttrap -qsigtrap -qlanglvl=95pure'
  oflags='-O -qmaxmem=-1'
  oflags='-O5'
  ;;
ifort)
  gflags='-O0 -p -g -CB -warn -traceback -u'
  oflags='-fast'
  [ $machine = teragrid ] && oflags='-O3'
  ;;
pgf90)
  gflags='-g -Mprof=lines'
  gflags='-O0 -g -Ktrap=fp -Mbounds -Mdclchk'
  oflags='-fast'
  ;;
gfortran)
  gflags='-O0 -pg -g -W -pedantic -std=f95 -fimplicit-none -fbounds-check -ffpe-trap=invalid,zero,overflow'
  oflags='-O3'
  ;;
f95)
  gflags='-g'
  oflags='-O'
  if [ $( uname ) = SunOS ]; then
    gflags='-g -w4 -u -C'
    oflags='-fast'
  fi
  ;;
*)
  echo "Error: no Fortran 95 compiler found"
  exit
esac
case $optimize in
  O) fflags=$oflags ;;
  g) fflags=$gflags ;;
esac

# Source files
base="
  globals.f90
  diffcn.f90
  diffnc.f90
  hourglass.f90
  optimize.f90
  bc.f90
  surfnormals.f90
  outprops.f90
  util.f90"
serial="
  serial.f90"
parallel="
  mpi.f90"
common="
  inread.f90
  setup.f90
  arrays.f90
  gridgen.f90
  output.f90
  momentsource.f90
  material.f90
  fault.f90
  metadata.f90
  resample.f90
  checkpoint.f90
  timestep.f90
  stress.f90
  acceleration.f90
  locknodes.f90
  sord.f90"

# Compile
cd f
case $mode in
  s) fc="$sfc"; collective="$serial" ;;
  p) fc="$pfc"; collective="$parallel" ;;
esac
make="$fc $fflags -o $srcdir/tmp/sord-$mode $base $collective $common"
echo "$make" > "$srcdir/tmp/state"
cat $base $collective $common >> "$srcdir/tmp/state" 
compile=yes
if [ -f "$srcdir/tmp/state-$mode" ]; then
  compile=$( cmp "$srcdir/tmp/state" "$srcdir/tmp/state-$mode" || : )
fi
if [ "$compile" ]; then
  rm -f "$srcdir/tmp/state-$mode"
  echo $make
  $make
  mv "$srcdir/tmp/state" "$srcdir/tmp/state-$mode"
fi
cd "$srcdir"

#------------------------------------------------------------------------------#
# Set-up

# Viz scripts
echo "cd $srcdir" > m/srcdir.m
cat << END > viz
#!/bin/bash -e
matlab -nojvm -nosplash -r "addpath $srcdir/m"
END
chmod u+x viz

# Setup run directory
sh/tarball
rundir="out/$count"
echo "Run directory: $rundir"
mkdir -p out
mkdir "$rundir"
cp 'in.m' tmp/sord.tgz tmp/sord-$mode tmp/input "$rundir"
if [ $optimize = g ]; then
  cp f/*.f90 "$rundir"
  chmod a-w "$rundir"/*.f90
fi
cd "$rundir"
rundir=$( /bin/pwd )
mkdir stats
mkdir timer
mkdir checkpoint
mkdir debug
i=0
while [ $i -lt $nout ]; do
  i=$(( i + 1 ))
  dir=$( echo $i | awk '{ printf "%02d", $1 }' )
  mkdir $dir
done
if [ "$datadir" ]; then
  cd "$srcdir/$datadir"
  datadir=$( /bin/pwd )
  cd "$rundir"
  ln -s "$datadir" 'data'
fi

# Write run metadata
cat << END > runmeta.m
login   = '$LOGNAME';
name    = '$( finger $LOGNAME | sed -n 's/^.*e: //p' )';
rundate = '$( date )';
rundir  = '$rundir';
datadir = '$datadir';
infile  = '$infile';
machine = '$machine';
host    = '$HOSTNAME';
os      = '$( uname -a )';
mode    = '$mode';
np      = $np;
END

#------------------------------------------------------------------------------#
# Run

case $machine in
datastar) . "$srcdir/sh/datastar" ;;
teragrid) . "$srcdir/sh/teragrid" ;;
babieca) . "$srcdir/sh/babieca" ;;
*)
[ "$mode" = p ] && mpich2version &> /dev/null && ! mpdtrace &> /dev/null && mpd --daemon
case $mode$run in
  si) ./sord-s ;;
  sg) ddd ./sord-s ;;
  sb) nice nohup ./sord-s > out.log & ;;
  pi) mpiexec -np $np ./sord-p ;;
  pg) mpiexec -gdb -np $np ./sord-p ;;
  pb) nice nohup mpiexec -np $np ./sord-p > out.log & ;;
esac
;;
esac

if [ "$run" = b ]; then
  echo "Background job started, to cancel: out/$count/kill.sh"
  echo "#!/bin/bash" > 'kill.sh'
  echo "kill $!" >> 'kill.sh'
  chmod u+x 'kill.sh'
fi
if [ "$pbsjob" ]; then
  echo "Job submitted to PBS, to cancel: out/$count/qdel.sh"
  echo "#!/bin/bash" > 'qdel.sh'
  echo "qdel $pbsjob" >> 'qdel.sh'
  chmod u+x 'qdel.sh'
fi

