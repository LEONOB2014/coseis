#!/bin/bash -e
#------------------------------------------------------------------------------#

echo -e "\nSORD setup"

# Get command line options
mode=guess
fflags=O
compile=yes
run=yes
debug=
deleteout=
while getopts spmcngGd opt; do
case $opt in
  s) mode=serial ;;
  p) mode=parallel ;;
  m) mode=matlab ;;
  c) run= ;;
  n) run= ; compile= ;;
  g) fflags=g ;;
  G) fflags=g; debug=g ;;
  d) deleteout=yes ;;
esac
done
shift $(( OPTIND - 1 ))

# Identify machine
osname=$( uname )
if   [ "${HOSTNAME:0:2}" = ds ]; then machine=DataStar
elif [ "${HOSTNAME:0:2}" = tg ]; then machine=TeraGrid
elif [ "$HOSTNAME" = master ];   then machine=Babieca
else machine=$osname
fi

# Symling input file specified on command line
[ -n "$1" ] && ln -sf "$1" 'in.m'

# Strip MATLAB caracters
sed "s/%.*$//; s/;/;\n/g; s/[]={}';[]*//g;/^$/d" 'defaults.m' 'in.m' > tmp

# Read input
nout=0
while read key params; do
set -- $params
case "$key" in
  nt)  nt=$1 ;;
  nn)  nn3=( $1 $2 $3 ) ;;
  np)  np3=( $1 $2 $3 ) ;;
  out) nout=$(( nout + 1 )) ;;
esac
done < tmp

# Create output folders
[ $deleteout ] && rm -rf out
[ -e out ]            || mkdir out
[ -e out/checkpoint ] || mkdir out/checkpoint
[ -e out/stats ]      || mkdir out/stats
i=0
while [ $i -lt $nout ]; do
  i=$(( i + 1 ))
  dir=$( echo $i | awk '{ printf "out/%02d", $1 }' )
  [ -e $dir ] || mkdir $dir
done
rm -f batchjob

# Problem size
nn=$(( nn3[0] * nn3[1] * nn3[2] ));
np=$(( np3[0] * np3[1] * np3[2] ));
[ $matlab ] && np=1

#------------------------------------------------------------------------------#
# Metadata

# Save source, input files & byte order
cp 'defaults.m' 'in.m' out/
perl -e 'print pack('V',1) eq pack('L',1) ? "l\n":"b\n"' > out/endian

# RAM usage and run time estimate
floatsize=4
nvars=21
ram=$(( nn / np * floatsize * nvars / 1024 / 1024 ))
rate=250000
[ $mode = matlab ] && rate=70000
wt=$(( nt * nn / np / rate + 1 ))
hh=$(( wt / 3600 ))
mm=$(( wt % 3600 / 60 ))
ss=$(( wt % 60 ))
[ $hh -ge 1 ] && ss=0
wt=$( echo $hh $mm $ss | awk '{ printf "%d:%02d:%02d\n", $1, $2, $3 }' )
echo "RAM usage: at least ${ram}Mb"
echo "Run time: at least $wt"

# Write metadata
cat << END > out/runmeta.m
login   = '$LOGNAME';
name    = '$( finger $LOGNAME | sed -n 's/^.*e: //p' )';
rundate = '$( date )';
rundir  = '$( /bin/pwd )';
machine = '$machine';
host    = '$HOSTNAME';
os      = '$( uname -a )';
END

cat << END > out/viz.m
addpath $( /bin/pwd )/viz
END

#------------------------------------------------------------------------------#
# Matlab backend

if [ $mode = matlab ]; then

cat << END > batchjob
#!/bin/bash -e
unset DISPLAY
nohup matlab -r 'sord, quit' > out.log &
END
chmod u+x batchjob

./tarball
cp sord.tgz out/

[ $run ] && matlab -nodesktop -nosplash -r "addpath m; sord"

exit

fi

#------------------------------------------------------------------------------#
# Compile Fortran

[ $mode = guess ] && [ $np -eq 1 ] && mode=serial
[ $mode = guess ] && [ $np -gt 1 ] && mode=parallel

# Defaults
fc='f95'
pfc='mpif90'
oflags='-O'
gflags='-g'

# Machine specific
case $machine in
  Linux)
    fc='gfortran'
    oflags='-g -W -pedantic -std=f95 -fimplicit-none'
    gflags='-g -W -pedantic -std=f95 -fimplicit-none'
    ;;
  SunOS)
    oflags='-fast'
    gflags='-g -w4 -u -C'
    ;;
  DataStar)
    fc='xlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg'
    pfc='mpxlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg'
    oflags='-O5'
    gflags='-g -C -qflttrap -qsigtrap -qlanglvl=95pure'
    ;;
  TeraGrid)
    fc='ifort'
    oflags='-fast'
    gflags='-g -CB -warn -traceback'
    ;;
  Babieca)
    fc='pgf95'
    ;;
esac
case $fflags in
  O) fflags=$oflags ;;
  g) fflags=$gflags ;;
esac

# Source files
common="\\
  globals.f90 \\
  diffcn.f90 \\
  diffnc.f90 \\
  hourglasscn.f90 \\
  hourglassnc.f90 \\
  surfnormals.f90 \\
  zone.f90 \\
  inread.f90 \\
  setup.f90 \\
  arrays.f90 \\
  optimize.f90 \\
  gridgen.f90 \\
  material.f90 \\
  momentsource.f90 \\
  fault.f90 \\
  checkpoint.f90 \\
  output.f90 \\
  pml.f90 \\
  stress.f90 \\
  acceleration.f90 \\
  locknodes.f90 \\
  timestep.f90 \\
  sord.f90"
serial="\\
  serial.f90 \\
  serialio.f90"
mpi="\\
  mpi.f90 \\
  mpiio.f90"

# Write makefile
cat << END > tmp
FC = $fc
PFC = $pfc
FFLAGS = $fflags
COMMON = $common
SERIAL = $serial
MPI = $mpi
VPATH = f
fsord: makefile \$(SERIAL) \$(COMMON)
	cd f; \$(FC) \$(FFLAGS) \$(SERIAL) \$(COMMON) -o ../fsord
psord: makefile \$(MPI) \$(COMMON)
	cd f; \$(PFC) \$(FFLAGS) \$(MPI) \$(COMMON) -o ../psord
sord.tgz: clean
	./tarball
clean:
	rm -f tmp f/*.mod
realclean: clean
	rm -f makefile fsord psord batchjob
.PHONY: clean realclean
END
[ ! -f makefile ] && touch makefile
[ "$( diff tmp makefile )" != "" ] && mv tmp makefile
rm -f tmp

# Compile
if [ $compile ]; then
case $mode in
  serial)   gmake fsord sord.tgz ;;
  parallel) gmake psord sord.tgz ;;
esac
fi
echo ''

#------------------------------------------------------------------------------#
# Batch submission and run commands

case $machine in

DataStar) #--------------------------------------#

cat << END
DataStar 8-way p655+ nodes
dspoe.sdsc.edu: 4GB?, 40proc?, 2hr limit
dslogin.sdsc.edu: 3672GB, 2176proc, 18hr limit
Useful commands:
  llsubmit batchjob
  llcancel <jobID>
  llq
  llq -s <jobID>
  show_q
  show_bf
  reslist
  showq
Always run from a subdirectory of /gpfs/
Login to dslogin.sdsc.edu to submit batch jobs
Login to dspoe.sdsc.edu to run interactively
END
[ $( pwd | grep -v gpfs ) ] || exit

# Batch
rate=100000
wt=$(( nt * nn / np / rate + 1 ))
hh=$(( wt / 3600 ))
mm=$(( wt % 3600 / 60 ))
ss=$(( wt % 60 ))
[ $hh -ge 1 ] && ss=0
wt=$( echo $hh $mm $ss | awk '{ printf "%d:%02d:%02d\n", $1, $2, $3 }' )
ppn=8
[ $ppn -gt $np ] && ppn=$np
nodes=$(( np / ppn + ( np % ppn > 0 ? 1 : 0 ) ))
opts="-tasks_per_node $ppn -nodes $nodes -rmpool 1 -euilib us -euidevice sn_all"
rundir=$( /bin/pwd )
cat << END > batchjob
#!/bin/bash
#@ environment = COPY_ALL;\\
AIXTHREAD_COND_DEBUG=OFF;\\
AIXTHREAD_MUTEX_DEBUG=OFF;\\
AIXTHREAD_RWLOCK_DEBUG=OFF;\\
AIXTHREAD_SCOPE=S;\\
MP_ADAPTER_USE=dedicated;\\
MP_CPU_USE=unique;\\
MP_CSS_INTERRUPT=no;\\
MP_EAGER_LIMIT=64K;\\
MP_EUIDEVELOP=min;\\
MP_EUIDEVICE=sn_single;\\
MP_EUILIB=us;\\
MP_POLLING_INTERVAL=100000;\\
MP_PULSE=0;\\
MP_SHARED_MEMORY=yes;\\
MP_SINGLE_THREAD=no;\\
RT_GRQ=ON;\\
SPINLOOPTIME=0;\\
YIELDLOOPTIME=0;
#@ wall_clock_limit = $wt
#@ class = normal
#@ node_usage = not_shared
#@ notify_user = $LOGNAME
#@ node = $nodes
#@ tasks_per_node = $ppn
#@ job_type = parallel
#@ network.MPI = sn_single,not_shared,US,HIGH
#@ notification = always
#@ job_name = job.dfm
#@ output = out.log
#@ error = err.log
#@ initialdir = $rundir
#@ queue
cd $rundir
poe ./psord $opts
END
chmod u+x batchjob

# Interactive
[ $run ] || exit
[ $HOSTNAME = ds100 ] || exit
case $mode$debug in
  serial)    ./fsord ;;
  parallel)  poe ./psord $opts ;;
  serialg)   totalview poe -a ./fsord $opts ;;
  parallelg) totalview poe -a ./psord $opts ;;
esac

;;

TeraGrid) #--------------------------------------#

cat << END
SDSC TeraGrid: http://www.sdsc.edu/teragrid/guide.html
Useful commands:
  qsub batchjob
  qstat -a
  qdel PBS_JOBID
  qstat -r
  qstat -f PBS_JOBID
  qstat -q
  qstat -Q
  qstat -B
  pbsnodes -a 
  show_q
  show_res
  showq
  show_bf
Always run from a subdirectory of /gpfs/
Login to tg-c127, tg-c128, tg-c129 or  tg-130 to run interactively
END

# Batch
rate=100000
wt=$(( nt * nn / np / rate + 1 ))
hh=$(( wt / 3600 ))
mm=$(( wt % 3600 / 60 ))
ss=$(( wt % 60 ))
[ $hh -ge 1 ] && ss=0
wt=$( echo $hh $mm $ss | awk '{ printf "%d:%02d:%02d\n", $1, $2, $3 }' )
ppn=2
[ $ppn -gt $np ] && ppn=$np
nodes=$(( np / ppn + ( np % ppn > 0 ? 1 : 0 ) ))
rundir=$( /bin/pwd )
cat << END > batchjob
#!/bin/bash
#PBS -q dque
#PBS -N sord_job
#PBS -l nodes=$nodes:ppn=$ppn
#PBS -l walltime=$wt
#PBS -o out.log
#PBS -e err.log
#PBS -V
cd $rundir
mpirun -v -machinefile \$PBS_NODEFILE -np $np ./psord
END
chmod u+x batchjob

# Interactive
[ $run ] || exit
[ ${HOSTNAME:0:5} = 'tg-c1' ] || exit
case $mode$debug in
  serial)   ./fsord ;;
  serialg)  gdb ./fsord ;;
  parallel) mpirun -v -machinefile \$PBS_NODEFILE -np $np ./psord ;;
esac

;;

Babieca) #--------------------------------------#

# Info
cat << END
Babieca: up to 19 procs
Useful commands:
  qsub batchjob
  pbsnodes -a
  pingd
  qstat
  qdel
END

# Batch
ppn=2
[ $ppn -gt $np ] && ppn=$np
nodes=$(( np / ppn + ( np % ppn > 0 ? 1 : 0 ) ))
rundir=$( /bin/pwd )
cat << END > batchjob
#!/bin/bash
#PBS -q workq
#PBS -N sord_job
#PBS -l nodes=$nodes:ppn=$ppn
#PBS -o out.log
#PBS -e err.log
#PBS -V
sleep 2
cd $rundir
mpiexec -np $np ./psord
END
chmod u+x batchjob

# Interactive
[ $run ] || exit
case $mode$debug in
  serial)    ./fsord ;;
  serialg)   gdb ./fsord ;;
  parallel)  mpiexec -np $np ./psord ;;
  parallelg) mpiexec -np $np -dbg=gdb ./psord ;;
esac

;;

*) #--------------------------------------#

# Batch
cat << END > batchjob
#!/bin/bash
nohup mpirun -np $np ./psord > out.log &
END
chmod u+x batchjob

# Interactive
[ $run ] || exit
case $mode$debug in
  serial)    ./fsord ;;
  serialg)   ddd ./fsord ;;
  parallel)  mpirun -np $np ./psord ;;
  parallelg) mpirun -np $np -dbg=ddd ./psord ;;
esac

;;

esac #--------------------------------------#

