#!/bin/bash -e

echo -e "\nSORD setup"

# Get command line options
mode=guess
fflags=O
setup=yes
run=
while getopts spibqgGnd opt; do
case "$opt" in
  s) mode=serial ;;
  p) mode=parallel ;;
  i) run=i ;;
  b) run=b ;;
  q) run=q ;;
  g) fflags=g ;;
  G) fflags=g; run=g ;;
  n) setup= ; run= ;;
  d) rm -rf r[0-9]*/ count;;
  *) exit ;;
esac
done
shift $(( OPTIND - 1 ))

# Symlink input file specified on command line
[ -n "$1" ] && ln -sf "$1" 'in.m'

# Prepare input file
cat 'defaults.m' 'in.m' | sed "
s/%.*$//;
s/;/\\
/g;
" | sed "
s/[]{}='/	[]/ /g;
s/  */ /g;
s/^ //;
s/ $//;
/^$/d
" > 'in.tmp'

# Read input
nout=0
while read key params; do
set -- $params
case "$key" in
  nt)  nt=$1 ;;
  nn)  nn3=( $1 $2 $3 ) ;;
  np)  np3=( $1 $2 $3 ) ;;
  out) nout=$(( nout + 1 )) ;;
  timeseries) nout=$(( nout + 1 )) ;;
  datadir) datadir="$1" ;;
  return) break ;;
esac
done < 'in.tmp'

[ -n "$run" -a "$run" != q ] && interactive=yes

# Host
machine=$HOSTNAME
if   [ "${machine:0:2}" = ds ]; then machine=datastar
elif [ "${machine:0:2}" = tg ]; then machine=teragrid
elif [ "$machine" = master ];   then machine=babieca
fi

# Machine attributes
ppn=1
rate=200
case $machine in
  altai)    rate=90  ;;
  phat)     rate=180 ;;
  phim)     rate=200 ;;
  babieca)  rate=160; ppn=2 ;;
  teragrid) rate=500; ppn=2 ;;
  datastar) ppn=8 ;;
esac

# Number of processors
[ $mode = serial ] && np3=( 1 1 1 )
np=$(( np3[0] * np3[1] * np3[2] ));
[ $mode = guess -a $np -eq 1 ] && mode=serial
[ $mode = guess -a $np -gt 1 ] && mode=parallel
[ $ppn -gt $np ] && ppn=$np
nodes=$(( np / ppn + ( np % ppn > 0 ? 1 : 0 ) ))

# Domain size
nn3[0]=$(( nn3[0] / np3[0] + 2 + ( nn3[0] % np3[0] > 0 ? 1 : 0 ) ))
nn3[1]=$(( nn3[1] / np3[1] + 2 + ( nn3[1] % np3[1] > 0 ? 1 : 0 ) ))
nn3[2]=$(( nn3[2] / np3[2] + 2 + ( nn3[2] % np3[2] > 0 ? 1 : 0 ) ))
nn=$(( nn3[0] * nn3[1] * nn3[2] ));

# RAM and Wall time usage
floatsize=4
nvars=21
ram=$(( nn * floatsize * nvars / 1024 / 1024 + 15 ))
[ $np -gt 1 ] && rate=$(( rate * 4 / 5 ))
wt=$(( ( ( nt + 2 ) * nn / rate / 100 + np ) / 10 + 1 ))
hh=$(( wt / 3600 ))
mm=$(( wt % 3600 / 60 ))
ss=$(( wt % 60 ))
[ $hh -ge 1 ] && ss=0
wt=$( echo $hh $mm $ss | awk '{ printf "%d:%02d:%02d\n", $1, $2, $3 }' )
echo "Machine: $machine"
echo "RAM usage: ${ram}Mb"
echo "Wall time: $wt"

# Wall time limit
wt=$(( ( ( nt + 2 ) * nn / rate / 100 + np ) / 400 + 1 ))
hh=$(( wt / 60 ))
mm=$(( wt % 60 ))
wt=$( echo $hh $mm | awk '{ printf "%d:%02d:00\n", $1, $2 }' )
echo "Wall time limit: $wt"

#------------------------------------------------------------------------------#
# Makefile

# Compiler
IFS=":$IFS"
for dir in $PATH; do
for file in xlf95_r ifort pgf90 gfortran f95; do
  if [ -x $dir/$file ]; then
    fc=$file
    break 2
  fi
done
done

pfc='mpif90'
case $fc in
xlf95_r)
  fc='xlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg'
  pfc='mpxlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg'
  gflags='-p -g -C -qflttrap -qsigtrap -qlanglvl=95pure'
  oflags='-O -qmaxmem=-1'
  oflags='-O5'
  ;;
ifort)
  gflags='-O0 -p -g -CB -warn -traceback -u'
  oflags='-O3'
  oflags='-fast'
  ;;
pgf90)
  gflags='-g -Mprof=func'
  oflags='-fastsse'
  ;;
gfortran)
  pfc='mpif90 -O0'
  gflags='-p -g -W -pedantic -std=f95 -fimplicit-none'
  oflags='-O3'
  ;;
f95)
  gflags='-g'
  oflags='-O'
  if [ $( uname ) = SunOS ]; then
    gflags='-g -w4 -u -C'
    oflags='-fast'
  fi
  ;;
*)
  echo "Error: no Fortran 95 compiler found"
  exit
esac

# Source files
base="\\
  diffcn.f90 \\
  diffnc.f90 \\
  hourglasscn.f90 \\
  hourglassnc.f90 \\
  surfnormals.f90 \\
  bc.f90 \\
  zone.f90 \\
  tictoc.f90 \\
  globals.f90"
serial="\\
  serial.f90 \\
  serialio.f90"
mpi="\\
  mpi.f90 \\
  mpiio.f90"
common="\\
  inread.f90 \\
  setup.f90 \\
  arrays.f90 \\
  optimize.f90 \\
  gridgen.f90 \\
  material.f90 \\
  momentsource.f90 \\
  fault.f90 \\
  checkpoint.f90 \\
  pml.f90 \\
  output.f90 \\
  stress.f90 \\
  acceleration.f90 \\
  locknodes.f90 \\
  timestep.f90 \\
  sord.f90"

case $fflags in
  O) fflags=$oflags ;;
  g) fflags=$gflags ;;
esac

# Write makefile
cat << END > tmp
FC = $fc
PFC = $pfc
FFLAGS = $fflags
BASE = $base
SERIAL = $serial
MPI = $mpi
COMMON = $common
VPATH = f
fsord: makefile \$(BASE) \$(SERIAL) \$(COMMON)
	cd f; \$(FC) \$(FFLAGS) \$(BASE) \$(SERIAL) \$(COMMON) -o ../fsord
	sh/tarball
psord: makefile \$(BASE) \$(MPI) \$(COMMON)
	cd f; \$(PFC) \$(FFLAGS) \$(BASE) \$(MPI) \$(COMMON) -o ../psord
	sh/tarball
clean:
	rm -f tmp f/*.o f/*.mod f/*.ipo
realclean: clean
	rm -f makefile fsord psord
.PHONY: clean realclean
END
[ ! -f makefile ] && touch makefile
[ "$( diff tmp makefile )" != "" ] && mv tmp makefile
rm -f tmp

#------------------------------------------------------------------------------#
# Compile & set up

[ "$setup" ] || exit

# Run number
[ -f count ] && count=$( cat count )
count=$(( count + 1 ))
echo $count > count
srcdir=$( /bin/pwd )
rundir=$( /bin/pwd )/r$count
mkdir $rundir

# Compile
case $mode in
  serial)   gmake fsord; cp fsord $rundir ;;
  parallel) gmake psord; cp psord $rundir ;;
esac
echo ''

# Viz scripts
echo "cd $srcdir" > m/srcdir.m
echo "cd $rundir" > m/rundir.m
echo "addpath $srcdir/m" > m/viz.m
cat << END > viz
#!/bin/bash -e
matlab -nodesktop -nosplash -r "addpath $srcdir/m"
END
chmod u+x viz

# Setup files and folders
echo "Run directory: r$count"
cp 'in.tmp' 'sord.tgz' $rundir
cd $rundir
mkdir checkpoint
mkdir stats
i=0
while [ $i -lt $nout ]; do
  i=$(( i + 1 ))
  dir=$( echo $i | awk '{ printf "%02d", $1 }' )
  mkdir $dir
done
[ "$datadir" ] && ln -s "$srcdir/$datadir" 'data'

# Write metadata
cat << END > runmeta.m
login   = '$LOGNAME';
name    = '$( finger $LOGNAME | sed -n 's/^.*e: //p' )';
rundate = '$( date )';
rundir  = '$rundir';
machine = '$machine';
host    = '$HOSTNAME';
os      = '$( uname -a )';
END

#------------------------------------------------------------------------------#
# Run

case $machine in

datastar) #--------------------------------------#

if [ $( pwd | grep -v gpfs ) ]; then
  echo "jobs must be run from /gpfs"
  exit
fi
if [ -n "$interactive" -a $HOSTNAME != ds100 ]; then
  echo "interactive jobs must be launched from dspoe"
  exit
fi
opts="-tasks_per_node $ppn -nodes $nodes -rmpool 1 -euilib us -euidevice sn_all"
if [ -z "$interactive" -a $mode = parallel ]; then
cat << END > llscript
#!/bin/bash
#@environment = COPY_ALL;\\
#AIXTHREAD_SCOPE=S;\\
#MP_ADAPTER_USE=dedicated;\\
#MP_CPU_USE=unique;\\
#MP_CSS_INTERRUPT=no;\\
#MP_EAGER_LIMIT=64K;\\
#MP_EUIDEVELOP=min;\\
#MP_LABELIO=yes;\\
#MP_POLLING_INTERVAL=100000;\\
#MP_PULSE=0;\\
#MP_SHARED_MEMORY=yes;\\
#MP_SINGLE_THREAD=no;\\
#RT_GRQ=ON;\\
#SPINLOOPTIME=0;\\
#YIELDLOOPTIME=0;
#@ class = normal
#@ node = $nodes
#@ tasks_per_node = $ppn
#@ wall_clock_limit = $wt
#@ node_usage = not_shared
#@ network.MPI = sn_all, shared, US
#@ job_type = parallel
#@ job_name = sord_job_$count
#@ output = out.log
#@ error = err.log
#@ notification = always
#@ notify_user = $LOGNAME
#@ initialdir = $rundir
#@ queue
cd $rundir
poe ./psord $opts
END
chmod u+x llscript
fi

case $mode$run in
  seriali)   ./fsord ;;
  serialg)   totalview ./fsord ;;
  serialb)   nohup ./fsord > errors & ;;
  paralleli) poe ./psord $opts ;;
  parallelg) tvpoe ./psord $opts ;;
  parallelb) nohup poe ./psord $opts > errors & ;;
  parallelq) lljob=$( llsubmit llscript ) ;;
esac

;;

teragrid) #--------------------------------------#

if [ $( pwd | grep -v gpfs ) ]; then
  echo "Error: jobs must be run from /gpfs"
  exit
fi

if [ "$interactive" ]; then
  hosts="tg-c127 tg-c128 tg-c129 tg-c130"
  match=
  for host in $hosts; do
    [ $host = $HOSTNAME ] && match=yes
    echo $node:2 >> mf
  done
  if [ -z "$match" ]; then
    echo "Error: interactive jobs must be launched from the following hosts:"
    echo "$inodes"
    exit
  fi
elif [ $mode = parallel ]; then
cat << END > pbsscript
#!/bin/bash
#PBS -q dque
#PBS -N sord_job_$count
#PBS -l nodes=$nodes:ppn=$ppn
#PBS -l walltime=$wt
#PBS -o out.log
#PBS -e err.log
#PBS -V
cd $rundir
mpirun -machinefile \$PBS_NODEFILE -np $np ./psord
END
chmod u+x pbsscript
fi

case $mode$run in
  seriali)   ./fsord ;;
  serialg)   totalview ./fsord ;;
  serialb)   nohup ./fsord > errors & ;;
  paralleli) mpirun -machinefile mf -np $np ./psord ;;
  parallelg) mpirun -tv -machinefile mf -np $np ./psord ;;
  parallelb) nohup mpirun -machinefile mf -np $np ./psord > errors & ;;
  parallelq) pbsjob=$( qsub pbsscript ) ;;
esac

;;

babieca) #--------------------------------------#

if [ -n "$interactive" ]; then
cat << END > mf
node37:2
node38:2
node39:2
node40:2
node41:2
node42:2
node43:2
node44:2
node45:2
node46:2
node47:2
node48:2
END
elif [ $mode = parallel ]; then
cat << END > pbsscript
#!/bin/bash
#PBS -q workq
#PBS -N sord_job_$count
#PBS -l nodes=$nodes:ppn=$ppn:mpi
#PBS -o out.log
#PBS -e err.log
#PBS -V
sleep 2
cd $rundir
mpiexec -n $np ./psord
END
chmod u+x pbsscript
fi
  
case $mode$run in
  seriali)   mpirun -machinefile mf ./fsord ;;
  serialg)   mpirun -machinefile mf -dbg=gdb ./fsord ;;
  serialb)   nohup mpirun -machinefile mf ./fsord > errors & ;;
  paralleli) mpirun -machinefile mf -np $np ./psord ;;
  parallelg) mpirun -machinefile mf -np $np -dbg=gdb ./psord ;;
  parallelb) nohup mpirun -machinefile mf -np $np ./psord > errors & ;;
  parallelq) pbsjob=$( qsub pbsscript ) ;;
esac

;;

*) #--------------------------------------#

[ "$mode" = parallel ] && mpich2version &> /dev/null && ! mpdtrace &> /dev/null && mpd --daemon
case $mode$run in
  seriali)   ./fsord ;;
  serialg)   ddd ./fsord ;;
  serialb)   nice nohup ./fsord > errors & ;;
  paralleli) mpiexec -np $np ./psord ;;
  parallelg) mpiexec -gdb -np $np ./psord ;;
  parallelb) nice nohup mpiexec -np $np ./psord > errors & ;;
esac

;;

esac #--------------------------------------#

if [ "$run" = b ]; then
  echo "Running in background, to cancel: r$count/kill.sh"
  echo "#!/bin/bash" > 'kill.sh'
  echo "kill $!" >> 'kill.sh'
  chmod u+x 'kill.sh'
fi
if [ "$pbsjob" ]; then
  echo "Job submitted to PBS, to cancel: r$count/qdel.sh"
  echo "#!/bin/bash" > 'qdel.sh'
  echo "qdel $pbsjob" >> 'qdel.sh'
  chmod u+x 'qdel.sh'
fi

