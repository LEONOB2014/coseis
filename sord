#!/bin/bash -e

echo "SORD setup"

# Get command line options
mode=guess
optimize=O
setup=yes
run=
while getopts spibqgGndf opt; do
case "$opt" in
  s) mode=s ;;
  p) mode=p ;;
  i) run=i ;;
  b) run=b ;;
  q) run=q ;;
  g) optimize=g ;;
  G) optimize=g; run=g ;;
  n) setup= ; run= ;;
  d) rm -rf [0-9][0-9] ;;
  f) rm -rf tmp ;;
  *) exit ;;
esac
done
shift $(( OPTIND - 1 ))

# Symlink input file specified on command line
if [ "$1" ]; then 
  infile="$1"
  [ -f "$infile" ] || exit
  ln -sf "$infile" 'in.m'
else
  infile=$( readlink 'in.m' ) || infile='in.m'
fi
mkdir -p tmp

# Locations
srcdir=$( /bin/pwd )
count=$( echo [0-9][0-9] | sed 's/.* //' )
[ $count = '[0-9][0-9]' ] && count=00
count=$( echo $count | awk '{ printf "%02d", $1+1 }' )
rundir="$srcdir/$count"

# Prepare input file
cat 'defaults.m' 'in.m' | sed "
s/%.*$//;
s/;/\\
/g;
" | sed "
s/[]{}='/	[]/ /g;
s/  */ /g;
s/^ //;
s/ $//;
/^$/d
" > tmp/input

# Read input
nout=0
while read key params; do
set -- $params
case "$key" in
  nt)  nt=$1 ;;
  nn)  nm3=( $1 $2 $3 ) ;;
  np)  np3=( $1 $2 $3 ) ;;
  out) nout=$(( nout + 1 )) ;;
  timeseries) nout=$(( nout + 1 )) ;;
  datadir) datadir="$1" ;;
  return) break ;;
esac
done < tmp/input

[ "$run" -a "$run" != q ] && interactive=yes

# Host
machine=$HOSTNAME
if   [ "${machine:0:2}" = ds ]; then machine=datastar
elif [ "${machine:0:2}" = tg ]; then machine=teragrid
elif [ "$machine" = master ];   then machine=babieca
fi

# Machine attributes
maxnodes=1; cpus=1; maxram=800; rate=200
case $machine in
  phat)                           maxram=800;   rate=180 ;;
  phim)                           maxram=2800;  rate=200 ;;
  altai)    maxnodes=1;   cpus=8; maxram=30000; rate=90  ;; 
  babieca)  maxnodes=36;  cpus=2; maxram=800;   rate=160 ;;
  teragrid) maxnodes=262; cpus=2; maxram=3000;  rate=500 ;;
  datastar) maxnodes=176; cpus=8; maxram=13500 ;;          
esac
echo "Machine: $machine"

# Number of processors
[ $mode = guess -a $(( maxnodes * cpus )) -eq 1 ] && mode=s
[ $mode = s ] && np3=( 1 1 1 )
np=$(( np3[0] * np3[1] * np3[2] ));
[ $mode = guess -a $np -eq 1 ] && mode=s
[ $mode = guess -a $np -gt 1 ] && mode=p
nodes=$(( np / cpus + ( np % cpus > 0 ? 1 : 0 ) ))
[ $nodes -gt $maxnodes ] && nodes=$maxnodes
ppn=$(( np / nodes + ( np % nodes > 0 ? 1 : 0 ) ))

# Domain size
nm3[0]=$(( nm3[0] / np3[0] + 2 + ( nm3[0] % np3[0] > 0 ? 1 : 0 ) ))
nm3[1]=$(( nm3[1] / np3[1] + 2 + ( nm3[1] % np3[1] > 0 ? 1 : 0 ) ))
nm3[2]=$(( nm3[2] / np3[2] + 2 + ( nm3[2] % np3[2] > 0 ? 1 : 0 ) ))
nm=$( echo ${nm3[*]} | awk '{ print $1 * $2 * $3 }' )

# RAM and Wall time usage
floatsize=4
nvars=24
ram=$( echo $ppn $nm $nvars $floatsize | awk '{ printf "%d", $1 * ( $2 * $3 * $4 / 1024 / 1024 + 15 ) }' )
mm=$( echo $nt $nm $ppn $cpus $rate | awk '{ printf "%d", ( $1 + 2 ) * $2 * $3 / $4 / $5 / 40000 + 10 }' )
hh=$(( mm / 60 ))
mm=$(( mm % 60 ))
walltime=$( echo $hh $mm | awk '{ printf "%d:%02d:00", $1, $2 }' )
echo "Processes: $np"
echo "Memory usage: ${ram}Mb per node"
echo "Wall time limit: $walltime"
[ $ppn -gt $cpus ]    && echo "Warning: exceding available CPUs ($cpus)"
[ $ram -gt $maxram ]  && echo "Warning: exceding available RAM (${maxram}Mb)"

[ "$setup" ] || exit

#------------------------------------------------------------------------------#

# Compiler
IFS=":$IFS"
for dir in $PATH; do
for file in xlf95_r ifort pgf90 gfortran f95; do
  if [ -x $dir/$file ]; then
    sfc=$file
    break 2
  fi
done
done
pfc='mpif90'
case $sfc in
xlf95_r)
  sfc='xlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg'
  pfc='mpxlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg'
  gflags='-p -g -C -qflttrap -qsigtrap -qlanglvl=95pure'
  oflags='-O -qmaxmem=-1'
  oflags='-O5'
  ;;
ifort)
  gflags='-O0 -p -g -CB -warn -traceback -u'
  oflags='-fast'
  [ $machine = teragrid ] && oflags='-O3'
  ;;
pgf90)
  gflags='-O0 -g -Ktrap=fp -Mbounds -Mdclchk -Mprof=lines'
  oflags='-fast'
  ;;
gfortran)
  gflags='-O0 -p -g -W -pedantic -std=f95 -fimplicit-none -fbounds-check'
  oflags='-O3'
  ;;
f95)
  gflags='-g'
  oflags='-O'
  if [ $( uname ) = SunOS ]; then
    gflags='-g -w4 -u -C'
    oflags='-fast'
  fi
  ;;
*)
  echo "Error: no Fortran 95 compiler found"
  exit
esac
case $optimize in
  O) fflags=$oflags ;;
  g) fflags=$gflags ;;
esac

# Source files
base="
  diffcn.f90
  diffnc.f90
  hourglasscn.f90
  hourglassnc.f90
  surfnormals.f90
  bc.f90
  zone.f90
  tictoc.f90
  globals.f90"
serial="
  serial.f90
  serialio.f90"
parallel="
  mpi.f90
  mpiio.f90"
common="
  inread.f90
  setup.f90
  arrays.f90
  optimize.f90
  gridgen.f90
  material.f90
  momentsource.f90
  fault.f90
  checkpoint.f90
  pml.f90
  output.f90
  stress.f90
  acceleration.f90
  locknodes.f90
  timestep.f90
  sord.f90"

# Compile
cd f
case $mode in
  s) fc="$sfc"; collective="$serial" ;;
  p) fc="$pfc"; collective="$parallel" ;;
esac
make="$fc $fflags -o $srcdir/tmp/sord-$mode $base $collective $common"
echo "$make" > "$srcdir/tmp/state"
cat $base $collective $common >> "$srcdir/tmp/state" 
compile=yes
if [ -f "$srcdir/tmp/state-$mode" ]; then
  compile=$( cmp "$srcdir/tmp/state" "$srcdir/tmp/state-$mode" || : )
fi
if [ "$compile" ]; then
  rm -f "$srcdir/tmp/state-$mode"
  echo $make
  $make
  mv "$srcdir/tmp/state" "$srcdir/tmp/state-$mode"
fi
cd "$srcdir"

#------------------------------------------------------------------------------#
# Set-up

# Viz scripts
echo "cd $srcdir" > m/srcdir.m
cat << END > viz
#!/bin/bash -e
matlab -nodesktop -nosplash -r "addpath $srcdir/m"
END
chmod u+x viz

# Setup run directory
sh/tarball
echo "Run directory: $count"
mkdir "$rundir"
cp 'in.m' tmp/sord.tgz tmp/sord-$mode tmp/input "$rundir"
if [ $optimize = g ]; then
  cp f/*.f90 "$rundir"
  chmod a-w "$rundir"/*.f90
fi
cd "$rundir"
mkdir stats
mkdir checkpoint
mkdir debug
i=0
while [ $i -lt $nout ]; do
  i=$(( i + 1 ))
  dir=$( echo $i | awk '{ printf "%02d", $1 }' )
  mkdir $dir
done
[ "$datadir" ] && ln -s "$srcdir/$datadir" 'data'

# Write run metadata
cat << END > runmeta.m
login   = '$LOGNAME';
name    = '$( finger $LOGNAME | sed -n 's/^.*e: //p' )';
rundate = '$( date )';
rundir  = '$rundir';
infile  = '$infile';
machine = '$machine';
host    = '$HOSTNAME';
os      = '$( uname -a )';
END

#------------------------------------------------------------------------------#
# Run

case $machine in

datastar) #--------------------------------------#

if [ $( pwd | grep -v gpfs ) ]; then
  echo "Error: jobs must be run from /gpfs"
  exit
fi
if [ "$interactive" -a $HOSTNAME != ds100 ]; then
  echo "Error: interactive jobs must be launched from dspoe"
  exit
fi
opts="-tasks_per_node $ppn -nodes $nodes -rmpool 1 -euilib us -euidevice sn_all"
if [ -z "$interactive" -a $mode = p ]; then
cat << END > llscript
#!/bin/bash
#@environment = COPY_ALL;\\
#AIXTHREAD_SCOPE=S;\\
#MP_ADAPTER_USE=dedicated;\\
#MP_CPU_USE=unique;\\
#MP_CSS_INTERRUPT=no;\\
#MP_EAGER_LIMIT=64K;\\
#MP_EUIDEVELOP=min;\\
#MP_LABELIO=yes;\\
#MP_POLLING_INTERVAL=100000;\\
#MP_PULSE=0;\\
#MP_SHARED_MEMORY=yes;\\
#MP_SINGLE_THREAD=no;\\
#RT_GRQ=ON;\\
#SPINLOOPTIME=0;\\
#YIELDLOOPTIME=0;
#@ class = normal
#@ node = $nodes
#@ tasks_per_node = $ppn
#@ wall_clock_limit = $walltime
#@ node_usage = not_shared
#@ network.MPI = sn_all, shared, US
#@ job_type = parallel
#@ job_name = sord-$count
#@ output = out.log
#@ error = err.log
#@ notification = always
#@ notify_user = $LOGNAME
#@ initialdir = $rundir
#@ queue
cd $rundir
poe ./sord-p $opts
END
chmod u+x llscript
fi

case $mode$run in
  si) ./sord-s ;;
  sg) totalview ./sord-s ;;
  sb) nohup ./sord-s > errors & ;;
  pi) poe ./sord-p $opts ;;
  pg) tvpoe ./sord-p $opts ;;
  pb) nohup poe ./sord-p $opts > errors & ;;
  pq) lljob=$( llsubmit llscript ) ;;
esac

;;

teragrid) #--------------------------------------#

if [ $( pwd | grep -v gpfs ) ]; then
  echo "Error: jobs must be run from /gpfs"
  exit
fi

if [ "$interactive" ]; then
cat << END > mf
tg-c127:2
tg-c128:2
tg-c129:2
tg-c130:2
END
if ! grep -q "$HOSTNAME" mf; then
  echo "Error: interactive jobs must be launched from the following hosts:"
  sed 's/^/  /; s/:2//' mf
  exit
fi
elif [ $mode = p ]; then
cat << END > pbsscript
#!/bin/bash
#PBS -q dque
#PBS -N sord-$count
#PBS -l nodes=$nodes:ppn=$ppn
#PBS -l walltime=$walltime
#PBS -o out.log
#PBS -e err.log
#PBS -V
cd $rundir
mpirun -machinefile \$PBS_NODEFILE -np $np ./sord-$mode
END
chmod u+x pbsscript
fi

case $mode$run in
  si) ./sord-s ;;
  sg) totalview ./sord-s ;;
  sb) nohup ./sord-s > errors & ;;
  pi) mpirun -machinefile mf -np $np ./sord-p ;;
  pg) mpirun -tv -machinefile mf -np $np ./sord-p ;;
  pb) nohup mpirun -machinefile mf -np $np ./sord-p > errors & ;;
  pq) pbsjob=$( qsub pbsscript ) ;;
esac

;;

babieca) #--------------------------------------#

if [ "$interactive" ]; then
cat << END > mf
node37:2
node38:2
node39:2
node40:2
node41:2
node42:2
node43:2
node44:2
node45:2
node46:2
node47:2
node48:2
END
else
cat << END > pbsscript
#!/bin/bash
#PBS -q workq
#PBS -N sord-$count
#PBS -l nodes=$nodes:ppn=$ppn
#PBS -l walltime=$walltime
#PBS -o out.log
#PBS -e err.log
#PBS -V
sleep 2
cd $rundir
mpiexec -n $np ./sord-$mode
END
chmod u+x pbsscript
fi
  
case $run in
  i) mpirun -machinefile mf -np $np ./sord-$mode ;;
  g) mpirun -machinefile mf -np $np -dbg=gdb ./sord-$mode ;;
  b) nohup mpirun -machinefile mf -np $np ./sord-$mode > errors & ;;
  q) pbsjob=$( qsub pbsscript ) ;;
esac

;;

*) #--------------------------------------#

[ "$mode" = p ] && mpich2version &> /dev/null && ! mpdtrace &> /dev/null && mpd --daemon
case $mode$run in
  si) ./sord-s ;;
  sg) ddd ./sord-s ;;
  sb) nice nohup ./sord-s > errors & ;;
  pi) mpiexec -np $np ./sord-p ;;
  pg) mpiexec -gdb -np $np ./sord-p ;;
  pb) nice nohup mpiexec -np $np ./sord-p > errors & ;;
esac

;;

esac #--------------------------------------#

if [ "$run" = b ]; then
  echo "Background job started, to cancel: $count/kill.sh"
  echo "#!/bin/bash" > 'kill.sh'
  echo "kill $!" >> 'kill.sh'
  chmod u+x 'kill.sh'
fi
if [ "$pbsjob" ]; then
  echo "Job submitted to PBS, to cancel: $count/qdel.sh"
  echo "#!/bin/bash" > 'qdel.sh'
  echo "qdel $pbsjob" >> 'qdel.sh'
  chmod u+x 'qdel.sh'
fi

