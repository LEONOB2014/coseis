#!/bin/bash -e
# Copyright 2007 Geoffrey Ely
# This software is released under the GNU General Public License

echo "SORD setup"
starttime=$(date)

# Get command line options
mode=guess
optimize=O
setup=yes
run=
velmodel=
while getopts spiqgGnv:m:df opt; do
case "$opt" in
  s) mode=s ;;
  p) mode=p ;;
  i) run=i ;;
  q) run=q ;;
  g) optimize=g ;;
  G) optimize=g; run=g ;;
  n) setup= ; run= ;;
  v) vm="scecvm$OPTARG" ;;
  m) machine="$OPTARG" ;;
  d) rm -rf run/[0-9][0-9] ;;
  f) rm -rf tmp/* ;;
  *) exit 1 ;;
esac
done
shift $(( OPTIND - 1 ))

# Email address
email="$LOGNAME"
[ -f email ] && email="$( cat email )"

# Symlink input file specified on command line
if [ "$1" ]; then 
  infile="$1"
  if [ ! -f "$infile" ]; then
    echo "Error: $infile not found"
    exit 1
  fi
  ln -sf "$infile" 'in.m'
fi
infile=$( readlink 'in.m' 2> /dev/null ) || infile='in.m'

# Make diretories
mkdir -p tmp
if [ -d /gpfs ]; then
  mkdir -p /gpfs/$LOGNAME/sord/run
  ln -sf /gpfs/$LOGNAME/sord/run
else
  mkdir -p run
fi

# Locations
srcdir=$( /bin/pwd )
count=$( echo run/[0-9][0-9] | sed 's/.*\///' )
[ "$count" = '[0-9][0-9]' ] && count=00
count=$( echo $count | awk '{ printf "%02d", $1+1 }' )
echo "$count" > tmp/count

# Prepare input file
. sh/inread

# Configure
. sh/config
echo "Machine: $machine"

# Number of processors
[ $mode = guess -a $(( maxnodes * maxcpus )) -eq 1 ] && mode=s
[ $mode = s ] && np3=( 1 1 1 )
np=$(( np3[0] * np3[1] * np3[2] ));
[ $mode = guess -a $np -eq 1 ] && mode=s
[ $mode = guess -a $np -gt 1 ] && mode=p
nodes=$(( np / maxcpus + ( np % maxcpus > 0 ? 1 : 0 ) ))
[ $nodes -gt $maxnodes ] && nodes=$maxnodes
ppn=$(( np / nodes + ( np % nodes > 0 ? 1 : 0 ) ))
cpus=$ppn
[ $cpus -gt $maxcpus ] && cpus=$maxcpus

# Domain size
nc=$( echo ${nm3[*]} | awk '{ print ( $1 - 1 ) * ( $2 - 1 ) * ( $3 - 1 ) }' )
nm3[0]=$(( nm3[0] / np3[0] + 2 + ( nm3[0] % np3[0] > 0 ? 1 : 0 ) ))
nm3[1]=$(( nm3[1] / np3[1] + 2 + ( nm3[1] % np3[1] > 0 ? 1 : 0 ) ))
nm3[2]=$(( nm3[2] / np3[2] + 2 + ( nm3[2] % np3[2] > 0 ? 1 : 0 ) ))
i=$(( faultnormal - 1 ))
[ $i -ge 0 ] && nm3[i]=$(( nm3[i] + 2 ))
nm=$( echo ${nm3[*]} | awk '{ print $1 * $2 * $3 }' )

# RAM and Wall time usage
floatsize=4
case "$oplevel" in
  1|2)   nvars=20 ;;
  3|4|5) nvars=23 ;;
  *)     nvars=44 ;;
esac
ramproc=$( echo $nm $nvars $floatsize 1.5 | \
  awk '{ printf "%.0f", ( $1 * $2 * $3 / 1024 / 1024 + 10 ) * $4 } ' )
ramnode=$( echo $nm $nvars $floatsize $ppn | \
  awk '{ printf "%.0f", ( $1 * $2 * $3 / 1024 / 1024 + 10 ) * $4 }' )
sus=$( echo $nt $ppn $nm $cpus $rate $nodes $maxcpus | \
  awk '{ printf "%.0f", ( $1 + 10 ) * $2 * $3 / $4 / $5 / 3600000 * $6 * $7 }' )
mm=$(  echo $nt $ppn $nm $cpus $rate 1.5 | \
  awk '{ printf "%.0f", ( $1 + 10 ) * $2 * $3 / $4 / $5 / 60000 * $6 + 10 }' )
[ $maxmm -gt 0 -a $mm -gt $maxmm ] && mm=$maxmm
hh=$(( mm / 60 ))
mm=$(( mm % 60 ))
walltime=$( echo $hh $mm | awk '{ printf "%d:%02d:00", $1, $2 }' )
echo "Procs: $np of $(( maxnodes * maxcpus ))"
echo "Nodes: $nodes of $maxnodes"
echo "RAM: ${ramnode}Mb of ${maxram}Mb per node"
echo "Time limit: $walltime"
echo "SUs: $sus"
[ $ppn -gt $maxcpus ] && \
  echo "Warning: exceding available CPUs per node ($maxcpus)"
[ $ramnode -gt $maxram ] && \
  echo "Warning: exceding available RAM per node (${maxram}Mb)"

[ "$setup" ] || exit 0

#------------------------------------------------------------------------------#

# Source files
base="
  globals.f90
  diffcn.f90
  diffnc.f90
  hourglass.f90
  bc.f90
  surfnormals.f90
  outprops.f90
  util.f90
  frio.f90"
common="
  inread.f90
  setup.f90
  arrays.f90
  gridgen.f90
  debug.f90
  output.f90
  source.f90
  material.f90
  fault.f90
  metadata.f90
  resample.f90
  checkpoint.f90
  timestep.f90
  stress.f90
  acceleration.f90
  sord.f90"

# Compile
cd f
case $optimize in
  O) fflags=$oflags; ;;
  g) fflags=$gflags; ;;
esac
case $mode in
  s) ../sh/compile "$sfc $fflags -o" ../tmp/sord-s $base serial.f90 $common ;;
  p) ../sh/compile "$pfc $fflags -o" ../tmp/sord-p $base mpi.f90 $common ;;
esac
cd "$srcdir"

#------------------------------------------------------------------------------#
# Set-up and run

# Setup run directory
sh/tarball
rundir="run/$count"
echo "Run directory: $rundir"
mkdir "$rundir"
echo "$starttime: SORD setup started" >> "$rundir/log"
cp 'in.m' tmp/sord.tgz tmp/sord-$mode tmp/input sh/clean "$rundir"
if [ $optimize = g ]; then
  cp f/*.f90 "$rundir"
  chmod a-w "$rundir"/*.f90
fi
cd "$rundir"
chmod a-w 'in.m'
rundir=$( /bin/pwd )
mkdir out
mkdir prof
mkdir stats
mkdir debug
mkdir checkpoint

# Write run metadata
cat << END > runmeta.m
% SORD run metadata
  login   = '$LOGNAME';
  name    = '$( finger $LOGNAME | sed -n '1s/^.*e: //p' )';
  rundate = '$( date )';
  rundir  = '$rundir';
  infile  = '$infile';
  machine = '$machine';
  host    = '$HOSTNAME';
  os      = '$( uname -a )';
  mode    = '$mode';
  np      = [ ${np3[*]} ];
END

# Run scripts
code="sord"
bin="./sord-$mode"
[ -x "$srcdir/sh/$machine" ] || . "$srcdir/sh/default"
[ -x "$srcdir/sh/$machine" ] && . "$srcdir/sh/$machine"

# SCECVM
if [ "$vm" ]; then
  if grep SAF "$srcdir/$infile" > /dev/null; then :; else
    echo "Error: SAF input file required for SCECVM"
    exit 1
  fi
  mkdir data
  "$srcdir/util/make"
  "$srcdir/vm/make"
  cp -r "$srcdir/tmp/$vm" vm
  cd vm
  ibig=$( cat ibig )
  nnl=$(( nc / np + ( nc % np > 0 ? 1 : 0 ) ))
  if [ "$ibig" -lt "$nnl" ]; then
    echo "Error: ibig=$ibig in newin.h must be >= $nnl"
    exit 1
  fi
  echo 1 > exag
  echo "$dx" > dx
  echo "$npml" > npml
  cp "$srcdir/tmp/safgrid" .
  cp "$srcdir/data/safsites.ll" .
  cp "$srcdir/data/topo3.f32" .
  cp "$srcdir/data/ts-ts1.f32" .
  cp "$srcdir/data/endian0" .
  echo "./safgrid"
  ./safgrid
  code="$vm"
  bin="./$vm-$mode nc rlon rlat rdep rho vp vs"
  post="mv endian meta.m ts1 x1 x2 x3 rho vp vs $rundir/data"
  walltime="02:00:00"
  topdir="$rundir"
  rundir="$topdir/vm"
  [ -x "$srcdir/sh/$machine" ] || . "$srcdir/sh/default"
  [ -x "$srcdir/sh/$machine" ] && . "$srcdir/sh/$machine"
  if [ "$run" = q ]; then
    echo ./que
    ./que
    run=""
  elif [ "$run" ]; then
    echo ./run "-$run"
    ./run "-$run"
  fi
  cd "$topdir"
elif [ "$datadir" ]; then
  mkdir data
  cd data
  for file in "$srcdir/$datadir/"*; do
    [ -f "$file" ] && ln "$file" . 2> /dev/null || cp "$file" .
  done
  endian="(not found)"
  [ -f endian ] && endian=$( cat endian )
  native="$( perl -le 'print pack('V',1) eq pack('L',1) ? "l" : "b"' )"
  if [ "$endian" != "$native" ]; then
    echo "Error: data endian=$endian, native endian=$native"
    exit 1
  fi
  cd "$rundir"
fi

echo "$(date): setup finished" >> log

# Run SORD
if [ "$run" = q ]; then
  echo ./que
  ./que
elif [ "$run" ]; then
  echo ./run "-$run"
  ./run "-$run"
fi

exit 0

