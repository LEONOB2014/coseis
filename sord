#!/bin/bash -e

echo -e "\nSORD setup"

# Get command line options
mode=guess
fflags=O
compile=yes
run=
while getopts spbicngGd opt; do
case "$opt" in
  s) mode=serial ;;
  p) mode=parallel ;;
  b) run=b ;;
  i) run=i ;;
  c) run= ;;
  n) run= ; compile= ;;
  g) fflags=g ;;
  G) fflags=g; run=g ;;
  d) rm -rf r[0-9]*/ count;;
  *) exit ;;
esac
done
shift $(( OPTIND - 1 ))

[ -f count ] && count=$( cat count )
count=$(( count + 1 ))
echo $count > count
srcdir=$( /bin/pwd )
rundir=$( /bin/pwd )/r$count
mkdir $rundir

# Symlink input file specified on command line
[ -n "$1" ] && ln -sf "$1" 'in.m'

# Ready input file
cat 'defaults.m' 'in.m' | sed "
s/%.*$//;
s/;/\\
/g;
" | sed "
s/[]{}='/	[]/ /g;
s/  */ /g;
s/^ //;
s/ $//;
/^$/d
" > "$rundir/in.tmp"

# Read input
nout=0
while read key params; do
set -- $params
case "$key" in
  nt)  nt=$1 ;;
  nn)  nn3=( $1 $2 $3 ) ;;
  np)  np3=( $1 $2 $3 ) ;;
  out) nout=$(( nout + 1 )) ;;
  timeseries) nout=$(( nout + 1 )) ;;
  datadir) echo ln -s "$1" "$rundir/data" ;;
  return) break
esac
done < "$rundir/in.tmp"

# Problem size
#nn=$(( nn3[0] * nn3[1] * nn3[2] )); # old bash can only handle 32 bits
nn=$( echo ${nn3[*]} | awk '{ printf "%d", $1 * $2 * $3 }' )
np=$(( np3[0] * np3[1] * np3[2] ));
[ $mode = guess ] && [ $np -eq 1 ] && mode=serial
[ $mode = guess ] && [ $np -gt 1 ] && mode=parallel

# Compilter
IFS=":$IFS"
for dir in $PATH; do
for file in xlf95_r ifort pgf90 gfortran f95; do
  if [ -x $dir/$file ]; then
    fc=$file
    break 2
  fi
done
done

pfc='mpif90'
case $fc in
xlf95_r)
  fc='xlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg'
  pfc='mpxlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg'
  gflags='-p -g -C -qflttrap -qsigtrap -qlanglvl=95pure'
  oflags='-O5'
  oflags='-O -qmaxmem=-1'
  ;;
ifort)
  gflags='-O0 -p -g -CB -warn -traceback -u'
  oflags='-fast'
  oflags='-O3'
  ;;
pgf90)
  gflags='-g -Mprof=func'
  oflags='-fastsse'
  ;;
gfortran)
  pfc='mpif90 -O0'
  gflags='-p -g -W -pedantic -std=f95 -fimplicit-none'
  oflags='-O3'
  ;;
f95)
  gflags='-g'
  oflags='-O'
  if [ $( uname ) = SunOS ]; then
    gflags='-g -w4 -u -C'
    oflags='-fast'
  fi
  ;;
*)
  echo "Error: no Fortran 95 compiler found"
  exit
esac

# Host
machine=$HOSTNAME
if   [ "${machine:0:2}" = ds ]; then machine=datastar
elif [ "${machine:0:2}" = tg ]; then machine=teragrid
elif [ "$machine" = master ];   then machine=babieca
fi
ppn=1
rate=30000
case $machine in
  datastar) ppn=8 ;;
  teragrid) ppn=2 ;;
  babieca)  ppn=2 ;;
esac

# Compute nodes
[ $ppn -gt $np ] && ppn=$np
nodes=$(( np / ppn + ( np % ppn > 0 ? 1 : 0 ) ))

# RAM and Wall time usage
floatsize=4
nvars=21
ram=$(( nn / np * floatsize * nvars / 1024 / 1024 ))
#wt=$(( nt * nn / np / rate + 1 )) # old bash can only handle 32 bits
wt=$( echo $nt $nn $np $rate | awk '{ printf "%d", $1 * $2 / $3 / $4 + 1 }' )
hh=$(( wt / 3600 ))
mm=$(( wt % 3600 / 60 ))
ss=$(( wt % 60 ))
[ $hh -ge 1 ] && ss=0
wt=$( echo $hh $mm $ss | awk '{ printf "%d:%02d:%02d\n", $1, $2, $3 }' )
echo "Machine: $machine"
echo "RAM usage: at least ${ram}Mb"
echo "Wall time: $wt"

# Wall time limit
rate=$(( rate * 2 / 3 ))
#wt=$(( nt * nn / np / rate + 1 )) # old bash can only handle 32 bits
wt=$( echo $nt $nn $np $rate | awk '{ printf "%d", $1 * $2 / $3 / $4 + 1 }' )
hh=$(( wt / 3600 ))
mm=$(( wt % 3600 / 60 ))
ss=$(( wt % 60 ))
[ $hh -ge 1 ] && ss=0
wt=$( echo $hh $mm $ss | awk '{ printf "%d:%02d:%02d\n", $1, $2, $3 }' )

#------------------------------------------------------------------------------#
# Compile Fortran

# Source files
base="\\
  diffcn.f90 \\
  diffnc.f90 \\
  hourglasscn.f90 \\
  hourglassnc.f90 \\
  surfnormals.f90 \\
  bc.f90 \\
  zone.f90 \\
  tictoc.f90 \\
  globals.f90"
serial="\\
  serial.f90 \\
  serialio.f90"
mpi="\\
  mpi.f90 \\
  mpiio.f90"
common="\\
  inread.f90 \\
  setup.f90 \\
  arrays.f90 \\
  optimize.f90 \\
  gridgen.f90 \\
  material.f90 \\
  momentsource.f90 \\
  fault.f90 \\
  checkpoint.f90 \\
  pml.f90 \\
  output.f90 \\
  stress.f90 \\
  acceleration.f90 \\
  locknodes.f90 \\
  timestep.f90 \\
  sord.f90"

case $fflags in
  O) fflags=$oflags ;;
  g) fflags=$gflags ;;
esac

# Write makefile
cat << END > tmp
FC = $fc
PFC = $pfc
FFLAGS = $fflags
BASE = $base
SERIAL = $serial
MPI = $mpi
COMMON = $common
VPATH = f
fsord: makefile \$(BASE) \$(SERIAL) \$(COMMON)
	cd f; \$(FC) \$(FFLAGS) \$(BASE) \$(SERIAL) \$(COMMON) -o ../fsord
	sh/tarball
psord: makefile \$(BASE) \$(MPI) \$(COMMON)
	cd f; \$(PFC) \$(FFLAGS) \$(BASE) \$(MPI) \$(COMMON) -o ../psord
	sh/tarball
clean:
	rm -f tmp f/*.o f/*.mod f/*.ipo
realclean: clean
	rm -f makefile fsord psord
.PHONY: clean realclean
END
[ ! -f makefile ] && touch makefile
[ "$( diff tmp makefile )" != "" ] && mv tmp makefile
rm -f tmp

# Compile
if [ $compile ]; then
case $mode in
  serial)   gmake fsord; cp fsord $rundir ;;
  parallel) gmake psord; cp psord $rundir ;;
esac
fi
echo ''

# SDX
echo "cd $srcdir" > m/srcdir.m
echo "cd $rundir" > m/rundir.m
echo "addpath $srcdir/m" > m/viz.m
cat << END > viz
#!/bin/bash -e
matlab -nodesktop -nosplash -r "addpath $srcdir/m"
END
chmod u+x viz

#------------------------------------------------------------------------------#
# Save source
cp 'sord.tgz' $rundir
cd $rundir

# Write metadata
cat << END > runmeta.m
login   = '$LOGNAME';
name    = '$( finger $LOGNAME | sed -n 's/^.*e: //p' )';
rundate = '$( date )';
rundir  = '$rundir';
machine = '$machine';
host    = '$HOSTNAME';
os      = '$( uname -a )';
END

# Create output folders
[ -e checkpoint ] || mkdir checkpoint
[ -e stats ]      || mkdir stats
i=0
while [ $i -lt $nout ]; do
  i=$(( i + 1 ))
  dir=$( echo $i | awk '{ printf "%02d", $1 }' )
  [ -e $dir ] || mkdir $dir
done

#------------------------------------------------------------------------------#
# Run

case $machine in

datastar) #--------------------------------------#

if [ $( pwd | grep -v gpfs ) ]; then
  echo "jobs must be run from /gpfs"
  exit
fi
if [ "$run" -a $HOSTNAME != ds100 ]; then
  echo "interactive jobs must be launched from dspoe"
  exit
fi
opts="-tasks_per_node $ppn -nodes $nodes -rmpool 1 -euilib us -euidevice sn_all"
case $mode$run in
  seriali)   ./fsord ;;
  serialg)   totalview ./fsord ;;
  serialb)   nohup ./fsord > errors & ;;
  paralleli) poe ./psord $opts ;;
  parallelg) tvpoe ./psord $opts ;;
  parallelb) nohup poe ./psord $opts > errors & ;;
  parallel)
	echo "To submit job:"
	echo "cd r$count; llsubmit batchjob"
	cat <<-END > batchjob
	#!/bin/bash
	#@environment = COPY_ALL;\\
	#AIXTHREAD_SCOPE=S;\\
	#MP_ADAPTER_USE=dedicated;\\
	#MP_CPU_USE=unique;\\
	#MP_CSS_INTERRUPT=no;\\
	#MP_EAGER_LIMIT=64K;\\
	#MP_EUIDEVELOP=min;\\
	#MP_LABELIO=yes;\\
	#MP_POLLING_INTERVAL=100000;\\
	#MP_PULSE=0;\\
	#MP_SHARED_MEMORY=yes;\\
	#MP_SINGLE_THREAD=no;\\
	#RT_GRQ=ON;\\
	#SPINLOOPTIME=0;\\
	#YIELDLOOPTIME=0;
	#@ class = normal
	#@ node = $nodes
	#@ tasks_per_node = $ppn
	#@ wall_clock_limit = $wt
	#@ node_usage = not_shared
	#@ network.MPI = sn_all, shared, US
	#@ job_type = parallel
	#@ job_name = sord_job_$count
	#@ output = out.log
	#@ error = err.log
	#@ notification = always
	#@ notify_user = $LOGNAME
	#@ initialdir = $rundir
	#@ queue
	cd $rundir
	poe ./psord $opts
	END
	chmod u+x batchjob
  ;;
esac

;;

teragrid) #--------------------------------------#

if [ $( pwd | grep -v gpfs ) ]; then
  echo "jobs must be run from /gpfs"
  exit
fi
if [ "$run" -a ${HOSTNAME:0:5} != 'tg-c1' ]; then
  echo "interactive jobs must be launched from tg-c127, 128, 129 or 130"
  exit
fi
[ -f "$srcdir/machinefile" ] || cat << END > "$srcdir/machinefile"
tg-c127:2
tg-c128:2
tg-c129:2
tg-c130:2
END
#export PAL_LICENSEFILE=/usr/local/apps/vampir/etc/license.dat
#export PAL_ROOT=/usr/local/apps/vampir
#export VT_ROOT=/usr/local/apps/vampirtrace
cp "$srcdir/machinefile" .
tail +$(( nodes + 1 )) machinefile > "$srcdir/machinefile"
head -$nodes machinefile >> "$srcdir/machinefile"
case $mode$run in
  seriali)   ./fsord ;;
  serialg)   totalview ./fsord ;;
  serialb)   nohup ./fsord > errors & ;;
  paralleli) mpirun -machinefile machinefile -np $np ./psord ;;
  parallelg) mpirun -tv -machinefile machinefile -np $np ./psord ;;
  parallelb) nohup mpirun -machinefile machinefile -np $np ./psord > errors & ;;
  parallel)
	echo "To submit job:"
	echo "cd r$count; qsub batchjob"
	cat <<-END > batchjob
	#!/bin/bash
	#PBS -q dque
	#PBS -N sord_job_$count
	#PBS -l nodes=$nodes:ppn=$ppn
	#PBS -l walltime=$wt
	#PBS -o out.log
	#PBS -e err.log
	#PBS -V
	cd $rundir
	mpirun -machinefile \$PBS_NODEFILE -np $np ./psord
	END
	chmod u+x batchjob
  ;;
esac

;;

babieca) #--------------------------------------#

[ -f "$srcdir/machinefile" ] || cat << END > "$srcdir/machinefile"
node37:2
node38:2
node39:2
node40:2
node41:2
node42:2
node43:2
node44:2
node45:2
node46:2
node47:2
node48:2
END
cp "$srcdir/machinefile" .
tail +$(( nodes + 1 )) machinefile > "$srcdir/machinefile"
head -$nodes machinefile >> "$srcdir/machinefile"
case $mode$run in
  seriali)   mpirun -machinefile machinefile ./fsord ;;
  serialg)   mpirun -machinefile machinefile -dbg=gdb ./fsord ;;
  serialb)   nohup mpirun -machinefile machinefile ./fsord > errors & ;;
  paralleli) mpirun -machinefile machinefile -np $np ./psord ;;
  parallelg) mpirun -machinefile machinefile -np $np -dbg=gdb ./psord ;;
  parallelb) nohup mpirun -machinefile machinefile -np $np ./psord > errors & ;;
  parallel)
	echo "To submit job:"
	echo "cd r$count; qsub batchjob"
	cat <<-END > batchjob
	#!/bin/bash
	#PBS -q workq
	#PBS -N sord_job_$count
	#PBS -l nodes=$nodes:ppn=$ppn:mpi
	#PBS -o out.log
	#PBS -e err.log
	#PBS -V
	sleep 2
	cd $rundir
	mpiexec -n $np ./psord
	END
	chmod u+x batchjob
  ;;
esac

;;

*) #--------------------------------------#

[ "$mode" = parallel ] && mpich2version &> /dev/null && ! mpdtrace &> /dev/null && mpd --daemon
case $mode$run in
  seriali)   ./fsord ;;
  serialg)   ddd ./fsord ;;
  serialb)   nice nohup ./fsord > errors & ;;
  paralleli) mpiexec -np $np ./psord ;;
  parallelg) mpiexec -gdb -np $np ./psord ;;
  parallelb) nice nohup mpiexec -np $np ./psord > errors & ;;
esac

;;

esac #--------------------------------------#

if [ "$run" = b ]; then
  echo "Running in background, to cancel: r$count/cancel.sh"
  echo "#!/bin/bash" > cancel.sh
  echo "kill $!" >> cancel.sh
  chmod u+x cancel.sh
fi

