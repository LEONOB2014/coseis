#!/bin/bash -e
# Usage: sord [-niqspgGfd] [-m <machine-name>] [<input-file>]
#   -n   check input only and exit
#   -i   run interactively
#   -q   submit job to batch system
#   -s   serial mode, no MPI (default if np == 1)
#   -p   parallel mode, requires MPI (default if np > 1)
#   -g   compile with debugging and syntax checking flags
#   -G   run in debugger
#   -f   force recompile
#   -d   delete output from previous runs before starting
#   -m   emulate alternative machine configuration, e.g. 'datastar'
#   <input-file> defaults is 'in.py'

# Log start time
starttime=$(date)
echo "SORD setup"

# Command line options
setup=yes
run=
mode=guess
optimize=O
while getopts niqspgGfdm: opt; do
case "$opt" in
    n) setup= ; run= ;;
    i) run=i ;;
    q) run=q ;;
    s) mode=s ;;
    p) mode=p ;;
    g) optimize=g ;;
    G) optimize=g; run=g ;;
    f) rm -rf tmp/* ;;
    d) rm -rf run/[0-9][0-9] ;;
    m) machine="$OPTARG" ;;
    *) exit 1 ;;
esac
done
shift $(( OPTIND - 1 ))
infile="$1"

# Locations
cwdir=$( /bin/pwd )
srcdir=$( basename $0 )
[ "$0" == "$( basename $0 )" ] && srcdir="$HOME/sord"
srcdir="$( cd $srcdir; /bin/pwd )"

# Email address
email="$LOGNAME"
[ -f "$srcdir/email" ] && email="$( cat "$srcdir/email" )"
[ -f email ] && email="$( cat email )"

# Make diretories
mkdir -p tmp
if [ -d /gpfs ]; then
    mkdir -p /gpfs/$LOGNAME/sord/run
    ln -sf /gpfs/$LOGNAME/sord/run
else
    mkdir -p run
fi

# Run count
count=$( echo run/[0-9][0-9] | sed 's/.*\///' )
[ "$count" = '[0-9][0-9]' ] && count=00
count=$( echo $count | awk '{ printf "%02d", $1+1 }' )

# Read SORD input file
. "$srcdir/sh/inread" "$srcdir/in/defaults.py" "$infile"

# Configure
. "$srcdir/sh/config"
echo "Machine: $machine"

# Number of processors
[ $mode = guess -a $(( maxnodes * maxcpus )) -eq 1 ] && mode=s
[ $mode = s ] && np3=( 1 1 1 )
np=$(( np3[0] * np3[1] * np3[2] ));
[ $mode = guess -a $np -eq 1 ] && mode=s
[ $mode = guess -a $np -gt 1 ] && mode=p
nodes=$(( np / maxcpus + ( np % maxcpus > 0 ? 1 : 0 ) ))
[ $nodes -gt $maxnodes ] && nodes=$maxnodes
ppn=$(( np / nodes + ( np % nodes > 0 ? 1 : 0 ) ))
cpus=$ppn
[ $cpus -gt $maxcpus ] && cpus=$maxcpus

# Domain size
nm3[0]=$(( nm3[0] / np3[0] + 2 + ( nm3[0] % np3[0] > 0 ? 1 : 0 ) ))
nm3[1]=$(( nm3[1] / np3[1] + 2 + ( nm3[1] % np3[1] > 0 ? 1 : 0 ) ))
nm3[2]=$(( nm3[2] / np3[2] + 2 + ( nm3[2] % np3[2] > 0 ? 1 : 0 ) ))
i=$(( faultnormal - 1 ))
[ $i -ge 0 ] && nm3[i]=$(( nm3[i] + 2 ))
nm=$( echo ${nm3[*]} | awk '{ print $1 * $2 * $3 }' )

# RAM and Wall time usage
floatsize=4
case "$oplevel" in
    1|2)   nvars=20 ;;
    3|4|5) nvars=23 ;;
    *)     nvars=44 ;;
esac
ramproc=$( echo $nm $nvars $floatsize 1.5 | \
    awk '{ printf "%.0f", ( $1 * $2 * $3 / 1024 / 1024 + 10 ) * $4 } ' )
ramnode=$( echo $nm $nvars $floatsize $ppn | \
    awk '{ printf "%.0f", ( $1 * $2 * $3 / 1024 / 1024 + 10 ) * $4 }' )
sus=$( echo $nt $ppn $nm $cpus $rate $nodes $maxcpus | \
    awk '{ printf "%.0f", ( $1 + 10 ) * $2 * $3 / $4 / $5 / 3600000 * $6 * $7 }' )
mm=$(  echo $nt $ppn $nm $cpus $rate 1.5 | \
    awk '{ printf "%.0f", ( $1 + 10 ) * $2 * $3 / $4 / $5 / 60000 * $6 + 10 }' )
[ $maxmm -gt 0 -a $mm -gt $maxmm ] && mm=$maxmm
hh=$(( mm / 60 ))
mm=$(( mm % 60 ))
walltime=$( echo $hh $mm | awk '{ printf "%d:%02d:00", $1, $2 }' )
echo "Procs: $np of $(( maxnodes * maxcpus ))"
echo "Nodes: $nodes of $maxnodes"
echo "RAM: ${ramnode}Mb of ${maxram}Mb per node"
echo "Time limit: $walltime"
echo "SUs: $sus"
[ $ppn -gt $maxcpus ] && \
    echo "Warning: exceding available CPUs per node ($maxcpus)"
[ $ramnode -gt $maxram ] && \
    echo "Warning: exceding available RAM per node (${maxram}Mb)"

[ "$setup" ] || exit 0

#------------------------------------------------------------------------------#
# Set-up and run

"$srcdir/make.sh" -"$mode$optimize"

# Setup run directory
rundir="run/$count"
echo "Run directory: $rundir"
mkdir "$rundir"
echo "$starttime: SORD setup started" >> "$rundir/log"
cp 'in.py' "$rundir"
cd "$rundir"
chmod a-w 'in.py'
cp \
    "$srcdir/tmp/sord.tgz" \
    "$srcdir/tmp/sord-$mode" \
    "$srcdir/tmp/input" \
    "$srcdir/sh/clean" .
if [ $optimize = g ]; then
    cp "$srcdir/src/*.f90" .
    chmod a-w *.f90
fi
mkdir out
mkdir prof
mkdir stats
mkdir debug
mkdir checkpoint

# Write run metadata
cat << END > runmeta.py
# SORD run metadata
login   = '$LOGNAME'
name    = '$( finger $LOGNAME | sed -n '1s/^.*e: //p' )'
rundate = '$( date )'
rundir  = '$rundir'
infile  = '$infile'
machine = '$machine'
host    = '$HOSTNAME'
os      = '$( uname -a )'
mode    = '$mode'
np      = [ ${np3[0]}, ${np3[1]}, ${np3[2]} ]
END

# Run scripts
rundir=$( /bin/pwd )
code="sord"
bin="./sord-$mode"
dir="$srcdir/sh/machine"
if [ -x  "$dir/$machine" ]
    then "$dir/$machine"
    else "$dir/default"
fi  

# Data directory
if [ "$datadir" ]; then
    mkdir data
    cd data
    for file in "$cwdir/$datadir/"*; do
        [ -f "$file" ] && ln "$file" . 2> /dev/null || cp "$file" .
    done
    endian="(not found)"
    [ -f endian ] && endian=$( cat endian )
    native="$( perl -le 'print pack('V',1) eq pack('L',1) ? "l" : "b"' )"
    if [ "$endian" != "$native" ]; then
        echo "Error: data endian=$endian, native endian=$native"
        exit 1
    fi
    cd "$rundir"
fi

echo "$(date): setup finished" >> log

# Que or run job
if [ "$run" = q ]; then
    echo ./que
    ./que
elif [ "$run" ]; then
    echo ./run "-$run"
    ./run "-$run"
fi

exit 0

