#!/bin/bash -e

echo -e "\nSORD setup"

# Get command line options
mode=guess
fflags=O
compile=yes
run=i
deleteout=
while getopts spmcngGbd opt; do
case $opt in
  s) mode=serial ;;
  p) mode=parallel ;;
  m) mode=matlab ;;
  c) run= ;;
  n) run= ; compile= ;;
  g) fflags=g ;;
  G) fflags=g; run=g ;;
  b) run=b ;;
  d) deleteout=yes ;;
esac
done
shift $(( OPTIND - 1 ))

# Identify machine
osname=$( uname )
if   [ "${HOSTNAME:0:2}" = ds ]; then machine=DataStar
elif [ "${HOSTNAME:0:2}" = tg ]; then machine=TeraGrid
elif [ "$HOSTNAME" = master ];   then machine=Babieca
else machine=$osname
fi

# Symling input file specified on command line
[ -n "$1" ] && ln -sf "$1" 'in.m'

# Strip MATLAB caracters
sed "s/%.*$//; s/;/;\
/g; s/[]={}';[]*//g; /^$/d" 'defaults.m' 'in.m' > tmp

# Read input
nout=0
while read key params; do
set -- $params
case "$key" in
  nt)  nt=$1 ;;
  nn)  nn3=( $1 $2 $3 ) ;;
  np)  np3=( $1 $2 $3 ) ;;
  out) nout=$(( nout + 1 )) ;;
esac
done < tmp

# Create output folders
[ $deleteout ] && rm -rf out
[ -e out ]            || mkdir out
[ -e out/checkpoint ] || mkdir out/checkpoint
[ -e out/stats ]      || mkdir out/stats
i=0
while [ $i -lt $nout ]; do
  i=$(( i + 1 ))
  dir=$( echo $i | awk '{ printf "out/%02d", $1 }' )
  [ -e $dir ] || mkdir $dir
done
rm -f batchjob

# Problem size
nn=$(( nn3[0] * nn3[1] * nn3[2] ));
np=$(( np3[0] * np3[1] * np3[2] ));
[ $matlab ] && np=1

#------------------------------------------------------------------------------#
# Metadata

# Save source, input files & byte order
cp 'defaults.m' 'in.m' out/
perl -e 'print pack('V',1) eq pack('L',1) ? "l\n":"b\n"' > out/endian

# RAM usage and run time estimate
floatsize=4
nvars=21
ram=$(( nn / np * floatsize * nvars / 1024 / 1024 ))
rate=250000
[ $mode = matlab ] && rate=70000
#wt=$(( nt * nn / np / rate + 1 )) # old bash can only handle 32 bits
wt=$( echo $nt $nn $np $rate | awk '{ printf "%d", $1 * $2 / $3 / $4 + 1 }' )
hh=$(( wt / 3600 ))
mm=$(( wt % 3600 / 60 ))
ss=$(( wt % 60 ))
[ $hh -ge 1 ] && ss=0
wt=$( echo $hh $mm $ss | awk '{ printf "%d:%02d:%02d\n", $1, $2, $3 }' )
echo "Machine: $machine"
echo "RAM usage: at least ${ram}Mb"
echo "Run time: at least $wt"

# Write metadata
cat << END > out/runmeta.m
login   = '$LOGNAME';
name    = '$( finger $LOGNAME | sed -n 's/^.*e: //p' )';
rundate = '$( date )';
rundir  = '$( /bin/pwd )';
machine = '$machine';
host    = '$HOSTNAME';
os      = '$( uname -a )';
END

cat << END > out/viz.m
addpath $( /bin/pwd )/viz
END

#------------------------------------------------------------------------------#
# Matlab backend

if [ $mode = matlab ]; then

cat << END > batchjob
#!/bin/bash -e
unset DISPLAY
nohup matlab -r 'sord, quit' > out.log &
END
chmod u+x batchjob

sh/tarball
cp sord.tgz out/

[ $run ] && matlab -nodesktop -nosplash -r "addpath m; sord"

exit

fi

#------------------------------------------------------------------------------#
# Compile Fortran

# Source files
common="\\
  globals.f90 \\
  diffcn.f90 \\
  diffnc.f90 \\
  hourglasscn.f90 \\
  hourglassnc.f90 \\
  surfnormals.f90 \\
  zone.f90 \\
  inread.f90 \\
  setup.f90 \\
  arrays.f90 \\
  optimize.f90 \\
  gridgen.f90 \\
  material.f90 \\
  momentsource.f90 \\
  fault.f90 \\
  checkpoint.f90 \\
  output.f90 \\
  pml.f90 \\
  stress.f90 \\
  acceleration.f90 \\
  locknodes.f90 \\
  timestep.f90 \\
  sord.f90"
serial="\\
  serial.f90 \\
  serialio.f90"
mpi="\\
  mpi.f90 \\
  mpiio.f90"

[ $mode = guess ] && [ $np -eq 1 ] && mode=serial
[ $mode = guess ] && [ $np -gt 1 ] && mode=parallel

# Defaults
fc='f95'
pfc='mpif90'
oflags='-O'
gflags='-g'

# Machine specific
case $machine in
  Linux)
    fc='gfortran'
    oflags="-fdefer-pop -fguess-branch-probability -fcprop-registers -floop-optimize -fif-conversion -fif-conversion2 -ftree-ccp -ftree-dce -ftree-dominator-opts -ftree-dse -ftree-ter -ftree-lrs -ftree-sra -ftree-copyrename -ftree-fre -ftree-ch -fmerge-constants -fomit-frame-pointer -fthread-jumps -fcrossjumping -foptimize-sibling-calls -fcse-follow-jumps -fcse-skip-blocks -fgcse -fgcse-lm -fexpensive-optimizations -fstrength-reduce -frerun-cse-after-loop -frerun-loop-opt -fcaller-saves -fforce-mem -fpeephole2 -fschedule-insns -fschedule-insns2 -fsched-interblock -fsched-spec -fregmove -fstrict-aliasing -fdelete-null-pointer-checks -freorder-blocks -freorder-functions -funit-at-a-time -falign-functions -falign-jumps -falign-loops -falign-labels -ftree-pre -finline-functions -funswitch-loops -fgcse-after-reload"
    oflags=''
    gflags='-g -W -pedantic -std=f95 -fimplicit-none'
    ;;
  SunOS)
    oflags='-fast'
    gflags='-g -w4 -u -C'
    ;;
  DataStar)
    fc='xlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg'
    pfc='mpxlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg'
    oflags='-O5'
    oflags='-O -qmaxmem=-1'
    gflags='-g -C -qflttrap -qsigtrap -qlanglvl=95pure'
    ;;
  TeraGrid)
    fc='ifort'
    oflags='-fast'
    gflags='-g -CB -warn -traceback'
    ;;
  Babieca)
    fc='pgf90'
    oflags='-fastsse -Mipa=fast'
    ;;
esac
case $fflags in
  O) fflags=$oflags ;;
  g) fflags=$gflags ;;
esac

# Write makefile
cat << END > tmp
FC = $fc
PFC = $pfc
FFLAGS = $fflags
COMMON = $common
SERIAL = $serial
MPI = $mpi
VPATH = f
fsord: makefile \$(SERIAL) \$(COMMON)
	cd f; \$(FC) \$(FFLAGS) \$(SERIAL) \$(COMMON) -o ../fsord
	sh/tarball
psord: makefile \$(MPI) \$(COMMON)
	cd f; \$(PFC) \$(FFLAGS) \$(MPI) \$(COMMON) -o ../psord
	sh/tarball
clean:
	rm -f tmp f/*.o f/*.mod
realclean: clean
	rm -f makefile fsord psord batchjob
.PHONY: clean realclean
END
[ ! -f makefile ] && touch makefile
[ "$( diff tmp makefile )" != "" ] && mv tmp makefile
rm -f tmp

# Compile
if [ $compile ]; then
case $mode in
  serial)   gmake fsord ;;
  parallel) gmake psord ;;
esac
fi
cp sord.tgz out/
echo ''

#------------------------------------------------------------------------------#
# Batch submission and run commands

case $machine in

DataStar) #--------------------------------------#

[ $( pwd | grep -v gpfs ) ] || exit

# Batch
rate=100000
wt=$(( nt * nn / np / rate + 1 ))
hh=$(( wt / 3600 ))
mm=$(( wt % 3600 / 60 ))
ss=$(( wt % 60 ))
[ $hh -ge 1 ] && ss=0
wt=$( echo $hh $mm $ss | awk '{ printf "%d:%02d:%02d", $1, $2, $3 }' )
ppn=8
[ $ppn -gt $np ] && ppn=$np
nodes=$(( np / ppn + ( np % ppn > 0 ? 1 : 0 ) ))
opts="-tasks_per_node $ppn -nodes $nodes -rmpool 1 -euilib us -euidevice sn_all"
rundir=$( /bin/pwd )
cat << END > batchjob
#!/bin/bash
#@environment = COPY_ALL;\\
#AIXTHREAD_COND_DEBUG=OFF;\\
#AIXTHREAD_MUTEX_DEBUG=OFF;\\
#AIXTHREAD_RWLOCK_DEBUG=OFF;\\
#AIXTHREAD_SCOPE=S;\\
#MP_ADAPTER_USE=dedicated;\\
#MP_CPU_USE=unique;\\
#MP_CSS_INTERRUPT=no;\\
#MP_EAGER_LIMIT=64K;\\
#MP_EUIDEVELOP=min;\\
#MP_LABELIO=no;\\
#MP_POLLING_INTERVAL=100000;\\
#MP_PULSE=0;\\
#MP_SHARED_MEMORY=yes;\\
#MP_SINGLE_THREAD=no;\\
#RT_GRQ=ON;\\
#SPINLOOPTIME=0;\\
#YIELDLOOPTIME=0;
#@ class = normal
#@ node = $nodes
#@ tasks_per_node = $ppn
#@ wall_clock_limit = $wt
#@ node_usage = not_shared
#@ network.MPI = sn_all, shared, US
#@ job_type = parallel
#@ job_name = job.dfm
#@ output = out.log
#@ error = err.log
#@ notification = always
#@ notify_user = $LOGNAME
#@ initialdir = $rundir
#@ queue
cd $rundir
poe ./psord $opts
END
chmod u+x batchjob

# Interactive
[ $HOSTNAME = ds100 ] || exit
case $mode$run in
  seriali)   ./fsord ;;
  serialg)   totalview poe -a ./fsord $opts ;;
  serialb)
    nohup ./fsord > out.log &
    echo "kill $!" > cancel.sh
    chmod u+x cancel.sh
  ;;
  paralleli) poe ./psord $opts ;;
  parallelg) totalview poe -a ./psord $opts ;;
  parallelb)
    nohup poe ./psord $opts > out.log &
    echo "kill $!" > cancel.sh
    chmod u+x cancel.sh
  ;;
esac

;;

TeraGrid) #--------------------------------------#

# Batch
rate=100000
wt=$(( nt * nn / np / rate + 1 ))
hh=$(( wt / 3600 ))
mm=$(( wt % 3600 / 60 ))
ss=$(( wt % 60 ))
[ $hh -ge 1 ] && ss=0
wt=$( echo $hh $mm $ss | awk '{ printf "%d:%02d:%02d\n", $1, $2, $3 }' )
ppn=2
[ $ppn -gt $np ] && ppn=$np
nodes=$(( np / ppn + ( np % ppn > 0 ? 1 : 0 ) ))
rundir=$( /bin/pwd )
cat << END > batchjob
#!/bin/bash
#PBS -q dque
#PBS -N sord_job
#PBS -l nodes=$nodes:ppn=$ppn
#PBS -l walltime=$wt
#PBS -o out.log
#PBS -e err.log
#PBS -V
cd $rundir
mpirun -v -machinefile \$PBS_NODEFILE -np $np ./psord
END
chmod u+x batchjob

# Interactive
[ $run ] || exit
[ ${HOSTNAME:0:5} = 'tg-c1' ] || exit
case $mode$run in
  seriali) ./fsord ;;
  serialg) gdb ./fsord ;;
  serialb)
    nohup ./fsord > out.log &
    echo "kill $!" > cancel.sh
    chmod u+x cancel.sh
    ;;
  paralleli) mpirun -v -machinefile \$PBS_NODEFILE -np $np ./psord ;;
  parallelb)
    nohup mpirun -v -machinefile \$PBS_NODEFILE -np $np ./psord > out.log &
    echo "kill $!" > cancel.sh
    chmod u+x cancel.sh
    ;;
esac

;;

Babieca) #--------------------------------------#

# Batch
ppn=2
[ $ppn -gt $np ] && ppn=$np
nodes=$(( np / ppn + ( np % ppn > 0 ? 1 : 0 ) ))
rundir=$( /bin/pwd )
cat << END > batchjob
#!/bin/bash
#PBS -q workq
#PBS -N sord_job
#PBS -l nodes=$nodes:ppn=$ppn:mpi
#PBS -o out.log
#PBS -e err.log
#PBS -V
sleep 2
cd $rundir
mpiexec -n $np ./psord
END
chmod u+x batchjob

# Interactive
cat << END > machinefile
node1:2
node2:2
node3:2
node4:2
node31:2
node32:2
node33:2
node34:2
node35:2
node36:2
END
case $mode$run in
  seriali) mpirun -machinefile machinefile ./fsord ;;
  serialg) mpirun -machinefile machinefile -dbg=gdb ./fsord ;;
  serialb)
    nohup mpirun -machinefile machinefile ./fsord > out.log &
    echo "kill $!" > cancel.sh
    chmod u+x cancel.sh
    ;;
  paralleli) mpirun -machinefile machinefile -np $np ./psord ;;
  parallelg) mpirun -machinefile machinefile -np $np -dbg=gdb ./psord ;;
  parallelb)
    nohup mpirun -machinefile machinefile -np $np ./psord > out.log &
    echo "kill $!" > cancel.sh
    chmod u+x cancel.sh
    ;;
esac

;;

*) #--------------------------------------#

#case $mode in
#  parallel) mpdtrace > /dev/null || mpd & ;;
#esac

# Interactive
case $mode$run in
  seriali) ./fsord ;;
  serialg) ddd ./fsord ;;
  serialb)
    nohup ./fsord > out.log &
    echo "kill $!" > cancel.sh
    chmod u+x cancel.sh
    ;;
  paralleli) mpirun -np $np ./psord ;;
  parallelg) mpirun -np $np -dbg=ddd ./psord ;;
  parallelb)
    nohup mpirun -np $np ./psord > out.log &
    echo "kill $!" > cancel.sh
    chmod u+x cancel.sh
    ;;
esac

;;

esac #--------------------------------------#

