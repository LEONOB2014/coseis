#!/bin/bash -e

echo -e "\nSORD setup"

# Get command line options
mode=guess
fflags=O
compile=yes
run=i
while getopts spmcngGbd opt; do
case $opt in
  s) mode=serial ;;
  p) mode=parallel ;;
  m) mode=matlab ;;
  c) run= ;;
  n) run= ; compile= ;;
  g) fflags=g ;;
  G) fflags=g; run=g ;;
  b) run=b ;;
  d) rm -rf out
esac
done
shift $(( OPTIND - 1 ))

srcdir=$( /bin/pwd )
rundir=$( /bin/pwd )/out/$( date +%Y-%m-%d-%H-%M-%S )
[ -e out ] || mkdir out
[ -e $rundir ] || mkdir $rundir
rm -f current
ln -s $rundir current

# Symlink input file specified on command line
[ -n "$1" ] && ln -sf "$1" 'in.m'

# Strip MATLAB caracters
sed "s/%.*$//; s/;/;\
/g; s/[]={}';[]*//g; /^$/d" 'defaults.m' 'in.m' > tmp

# Read input
nout=0
while read key params; do
set -- $params
case "$key" in
  nt)  nt=$1 ;;
  nn)  nn3=( $1 $2 $3 ) ;;
  np)  np3=( $1 $2 $3 ) ;;
  out) nout=$(( nout + 1 )) ;;
esac
done < tmp

# Problem size
nn=$(( nn3[0] * nn3[1] * nn3[2] ));
np=$(( np3[0] * np3[1] * np3[2] ));
[ $mode = matlab ] && np=1
[ $mode = guess ] && [ $np -eq 1 ] && mode=serial
[ $mode = guess ] && [ $np -gt 1 ] && mode=parallel

# Compilter
IFS=":$IFS"
for dir in $PATH; do
for file in xlf95_r ifort pgf90 gfortran f95; do
  if [ -x $dir/$file ]; then
    fc=$file
    break 2
  fi
done
done

pfc='mpif90'
case $fc in
xlf90_r)
  fc='xlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg'
  pfc='mpxlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg'
  gflags='-g -C -qflttrap -qsigtrap -qlanglvl=95pure'
  oflags='-O5'
  oflags='-O -qmaxmem=-1'
  ;;
ifort)
  gflags='-g -CB -warn -traceback'
  oflags='-fast'
  ;;
pgf90)
  gflags='-g'
  oflags='-fastsse -Mipa=fast'
  ;;
gfortran)
  gflags='-g -W -pedantic -std=f95 -fimplicit-none'
  oflags="-fdefer-pop -fguess-branch-probability -fcprop-registers -floop-optimize -fif-conversion -fif-conversion2 -ftree-ccp -ftree-dce -ftree-dominator-opts -ftree-dse -ftree-ter -ftree-lrs -ftree-sra -ftree-copyrename -ftree-fre -ftree-ch -fmerge-constants -fomit-frame-pointer -fthread-jumps -fcrossjumping -foptimize-sibling-calls -fcse-follow-jumps -fcse-skip-blocks -fgcse -fgcse-lm -fexpensive-optimizations -fstrength-reduce -frerun-cse-after-loop -frerun-loop-opt -fcaller-saves -fforce-mem -fpeephole2 -fschedule-insns -fschedule-insns2 -fsched-interblock -fsched-spec -fregmove -fstrict-aliasing -fdelete-null-pointer-checks -freorder-blocks -freorder-functions -funit-at-a-time -falign-functions -falign-jumps -falign-loops -falign-labels -ftree-pre -finline-functions -funswitch-loops -fgcse-after-reload"
  ;;
f95)
  gflags='-g'
  oflags='-O'
  if [ $( uname ) = SunOS ]; then
    gflags='-g -w4 -u -C'
    oflags='-fast'
  fi
  ;;
*)
  echo "Error: no Fortran 95 compiler found"
  exit
esac

# Host
machine=$HOSTNAME
if   [ "${machine:0:2}" = ds ]; then machine=datastar
elif [ "${machine:0:2}" = tg ]; then machine=teragrid
elif [ "$machine" = master ];   then machine=babieca
fi
ppn=1
rate=250000
case $machine in
  phat)     ;;
  phim)     ;;
  altai)    rate=177000 ;;
  datastar) ppn=8 ;;
  teragrid) ppn=2 ;;
  babieca)  ppn=2 ;;
esac
[ $mode = matlab ] && rate=$(( rate / 3 ))

# Compute nodes
[ $ppn -gt $np ] && ppn=$np
nodes=$(( np / ppn + ( np % ppn > 0 ? 1 : 0 ) ))

# RAM and Wall time usage
floatsize=4
nvars=21
ram=$(( nn / np * floatsize * nvars / 1024 / 1024 ))
#wt=$(( nt * nn / np / rate + 1 )) # old bash can only handle 32 bits
wt=$( echo $nt $nn $np $rate | awk '{ printf "%d", $1 * $2 / $3 / $4 + 1 }' )
hh=$(( wt / 3600 ))
mm=$(( wt % 3600 / 60 ))
ss=$(( wt % 60 ))
[ $hh -ge 1 ] && ss=0
wt=$( echo $hh $mm $ss | awk '{ printf "%d:%02d:%02d\n", $1, $2, $3 }' )
echo "Machine: $machine"
echo "RAM usage: at least ${ram}Mb"
echo "Wall time: $wt"

# Wall time limit
rate=$(( rate * 2 / 3 ))
#wt=$(( nt * nn / np / rate + 1 )) # old bash can only handle 32 bits
wt=$( echo $nt $nn $np $rate | awk '{ printf "%d", $1 * $2 / $3 / $4 + 1 }' )
hh=$(( wt / 3600 ))
mm=$(( wt % 3600 / 60 ))
ss=$(( wt % 60 ))
[ $hh -ge 1 ] && ss=0

#------------------------------------------------------------------------------#
# Compile Fortran

# Source files
common="\\
  globals.f90 \\
  diffcn.f90 \\
  diffnc.f90 \\
  hourglasscn.f90 \\
  hourglassnc.f90 \\
  surfnormals.f90 \\
  zone.f90 \\
  inread.f90 \\
  setup.f90 \\
  arrays.f90 \\
  optimize.f90 \\
  gridgen.f90 \\
  material.f90 \\
  momentsource.f90 \\
  fault.f90 \\
  checkpoint.f90 \\
  output.f90 \\
  pml.f90 \\
  stress.f90 \\
  acceleration.f90 \\
  locknodes.f90 \\
  timestep.f90 \\
  sord.f90"
serial="\\
  serial.f90 \\
  serialio.f90"
mpi="\\
  mpi.f90 \\
  mpiio.f90"

case $fflags in
  O) fflags=$oflags ;;
  g) fflags=$gflags ;;
esac

# Write makefile
cat << END > tmp
FC = $fc
PFC = $pfc
FFLAGS = $fflags
COMMON = $common
SERIAL = $serial
MPI = $mpi
VPATH = f
fsord: makefile \$(SERIAL) \$(COMMON)
	cd f; \$(FC) \$(FFLAGS) \$(SERIAL) \$(COMMON) -o ../fsord
	sh/tarball
psord: makefile \$(MPI) \$(COMMON)
	cd f; \$(PFC) \$(FFLAGS) \$(MPI) \$(COMMON) -o ../psord
	sh/tarball
clean:
	rm -f tmp f/*.o f/*.mod
realclean: clean
	rm -f makefile fsord psord
.PHONY: clean realclean
END
[ ! -f makefile ] && touch makefile
[ "$( diff tmp makefile )" != "" ] && mv tmp makefile
rm -f tmp

# Compile
if [ $compile ]; then
case $mode in
  serial)   gmake fsord; cp fsord $rundir ;;
  parallel) gmake psord; cp psord $rundir ;;
esac
fi
echo ''

# Viz
cat << END > viz.m
addpath $srcdir/viz
END

#------------------------------------------------------------------------------#
# Save source, input files & byte order
cp 'defaults.m' 'in.m' 'sord.tgz' $rundir
cd $rundir

# Write metadata
perl -e 'print pack('V',1) eq pack('L',1) ? "l\n":"b\n"' > endian
cat << END > runmeta.m
login   = '$LOGNAME';
name    = '$( finger $LOGNAME | sed -n 's/^.*e: //p' )';
rundate = '$( date )';
rundir  = '$rundir';
machine = '$machine';
host    = '$HOSTNAME';
os      = '$( uname -a )';
END

# Create output folders
[ -e checkpoint ] || mkdir checkpoint
[ -e stats ]      || mkdir stats
[ -e data ]       || ln -s ../../data
i=0
while [ $i -lt $nout ]; do
  i=$(( i + 1 ))
  dir=$( echo $i | awk '{ printf "%02d", $1 }' )
  [ -e $dir ] || mkdir $dir
done

#------------------------------------------------------------------------------#
# Run MATLAB version

if [ $mode = matlab ]; then
case $run in
  i) matlab -nodesktop -nosplash -r "addpath $srcdir/m; sord" ;;
  b) nohup matlab -nodisplay -nojvm -r "addpath $srcdir/m; sord" > out.log &
     echo "#!/bin/bash" > cancel.sh
     echo "kill $!" >> cancel.sh
     chmod u+x cancel.sh
  ;;
esac
exit
fi

#------------------------------------------------------------------------------#
# Run Fortran version

case $machine in

datastar) #--------------------------------------#

[ $( pwd | grep -v gpfs ) ] || exit

# Batch
opts="-tasks_per_node $ppn -nodes $nodes -rmpool 1 -euilib us -euidevice sn_all"
cat << END > batchjob
#!/bin/bash
#@environment = COPY_ALL;\\
#AIXTHREAD_COND_DEBUG=OFF;\\
#AIXTHREAD_MUTEX_DEBUG=OFF;\\
#AIXTHREAD_RWLOCK_DEBUG=OFF;\\
#AIXTHREAD_SCOPE=S;\\
#MP_ADAPTER_USE=dedicated;\\
#MP_CPU_USE=unique;\\
#MP_CSS_INTERRUPT=no;\\
#MP_EAGER_LIMIT=64K;\\
#MP_EUIDEVELOP=min;\\
#MP_LABELIO=no;\\
#MP_POLLING_INTERVAL=100000;\\
#MP_PULSE=0;\\
#MP_SHARED_MEMORY=yes;\\
#MP_SINGLE_THREAD=no;\\
#RT_GRQ=ON;\\
#SPINLOOPTIME=0;\\
#YIELDLOOPTIME=0;
#@ class = normal
#@ node = $nodes
#@ tasks_per_node = $ppn
#@ wall_clock_limit = $wt
#@ node_usage = not_shared
#@ network.MPI = sn_all, shared, US
#@ job_type = parallel
#@ job_name = job.dfm
#@ output = out.log
#@ error = err.log
#@ notification = always
#@ notify_user = $LOGNAME
#@ initialdir = $rundir
#@ queue
cd $rundir
poe ./psord $opts
END
chmod u+x batchjob

# Interactive
[ $HOSTNAME = ds100 ] || exit
case $mode$run in
  seriali)   ./fsord ;;
  serialg)   totalview poe -a ./fsord $opts ;;
  serialb)   nohup ./fsord > out.log & ;;
  paralleli) poe ./psord $opts ;;
  parallelg) totalview poe -a ./psord $opts ;;
  parallelb) nohup poe ./psord $opts > out.log & ;;
esac

;;

teragrid) #--------------------------------------#

# Batch
cat << END > batchjob
#!/bin/bash
#PBS -q dque
#PBS -N sord_job
#PBS -l nodes=$nodes:ppn=$ppn
#PBS -l walltime=$wt
#PBS -o out.log
#PBS -e err.log
#PBS -V
cd $rundir
mpirun -v -machinefile \$PBS_NODEFILE -np $np ./psord
END
chmod u+x batchjob

# Interactive
[ $run ] || exit
[ ${HOSTNAME:0:5} = 'tg-c1' ] || exit
case $mode$run in
  seriali)   ./fsord ;;
  serialg)   gdb ./fsord ;;
  serialb)   nohup ./fsord > out.log & ;;
  paralleli) mpirun -v -machinefile \$PBS_NODEFILE -np $np ./psord ;;
  parallelb)
    nohup mpirun -v -machinefile \$PBS_NODEFILE -np $np ./psord > out.log &
    ;;
esac

;;

babieca) #--------------------------------------#

# Batch
cat << END > batchjob
#!/bin/bash
#PBS -q workq
#PBS -N sord_job
#PBS -l nodes=$nodes:ppn=$ppn:mpi
#PBS -o out.log
#PBS -e err.log
#PBS -V
sleep 2
cd $rundir
mpiexec -n $np ./psord
END
chmod u+x batchjob

# Interactive
[ -f machinefile ] || cat << END > machinefile
node1:2
node2:2
node3:2
node4:2
node31:2
node32:2
node33:2
node34:2
node35:2
node36:2
END
case $mode$run in
  seriali)   mpirun -machinefile machinefile ./fsord ;;
  serialg)   mpirun -machinefile machinefile -dbg=gdb ./fsord ;;
  serialb)   nohup mpirun -machinefile machinefile ./fsord > out.log & ;;
  paralleli) mpirun -machinefile machinefile -np $np ./psord ;;
  parallelg) mpirun -machinefile machinefile -np $np -dbg=gdb ./psord ;;
  parallelb) nohup mpirun -machinefile machinefile -np $np ./psord > out.log &;;
esac
tail +$(( nodes + 1 )) machinefile > tmp
head -$nodes machinefile >> tmp
mv tmp machinefile

;;

*) #--------------------------------------#

#case $mode in
#  parallel) mpdtrace > /dev/null || mpd & ;;
#esac

# Interactive
case $mode$run in
  seriali)   nice ./fsord ;;
  serialg)   ddd ./fsord ;;
  serialb)   nice nohup ./fsord > out.log & ;;
  paralleli) nice mpirun -np $np ./psord ;;
  parallelg) mpirun -np $np -dbg=ddd ./psord ;;
  parallelb) nice nohup mpirun -np $np ./psord > out.log & ;;
esac

;;

esac #--------------------------------------#

if [ x$run = xb ]; then
  echo "#!/bin/bash" > cancel.sh
  echo "kill $!" >> cancel.sh
  chmod u+x cancel.sh
fi

