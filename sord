#!/bin/bash -e

echo -e "\nSORD setup"

# Get command line options
mode=guess
fflags=O
compile=yes
run=b
while getopts spicngGd opt; do
case "$opt" in
  s) mode=serial ;;
  p) mode=parallel ;;
  i) run=i ;;
  c) run= ;;
  n) run= ; compile= ;;
  g) fflags=g ;;
  G) fflags=g; run=g ;;
  d) rm -rf r[0-9]*/ count;;
  *) exit ;;
esac
done
shift $(( OPTIND - 1 ))

[ -f count ] && count=$( cat count )
count=$(( count + 1 ))
echo $count > count
srcdir=$( /bin/pwd )
rundir=$( /bin/pwd )/r$count
mkdir $rundir

# Symlink input file specified on command line
[ -n "$1" ] && ln -sf "$1" 'in.m'

# Ready input file
cat 'defaults.m' 'in.m' | sed "
s/%.*$//;
s/;/\\
/g;
" | sed "
s/[]{}='/	[]/ /g;
s/  */ /g;
s/^ //;
s/ $//;
/^$/d
" > "$rundir/in.tmp"

# Read input
nout=0
while read key params; do
set -- $params
case "$key" in
  nt)  nt=$1 ;;
  nn)  nn3=( $1 $2 $3 ) ;;
  np)  np3=( $1 $2 $3 ) ;;
  out) nout=$(( nout + 1 )) ;;
  timeseries) nout=$(( nout + 1 )) ;;
  datadir) echo ln -s "$1" "$rundir/data" ;;
  return) break
esac
done < "$rundir/in.tmp"

# Problem size
#nn=$(( nn3[0] * nn3[1] * nn3[2] )); # old bash can only handle 32 bits
nn=$( echo ${nn3[*]} | awk '{ printf "%d", $1 * $2 * $3 }' )
np=$(( np3[0] * np3[1] * np3[2] ));
[ $mode = guess ] && [ $np -eq 1 ] && mode=serial
[ $mode = guess ] && [ $np -gt 1 ] && mode=parallel

# Compilter
IFS=":$IFS"
for dir in $PATH; do
for file in xlf95_r ifort pgf90 gfortran f95; do
  if [ -x $dir/$file ]; then
    fc=$file
    break 2
  fi
done
done

pfc='mpif90'
case $fc in
xlf95_r)
  fc='xlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg'
  pfc='mpxlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg'
  gflags='-g -C -qflttrap -qsigtrap -qlanglvl=95pure'
  oflags='-O5'
  oflags='-O -qmaxmem=-1'
  ;;
ifort)
  gflags='-g -CB -warn -traceback -u'
  oflags='-fast'
  oflags='-O3 -static'
  oflags='-O0'
  ;;
pgf90)
  gflags='-g'
  oflags='-fastsse -Mipa=fast'
  ;;
gfortran)
  pfc='mpif90 -O0'
  gflags='-g -W -pedantic -std=f95 -fimplicit-none'
  oflags="-fdefer-pop -fguess-branch-probability -fcprop-registers -floop-optimize -fif-conversion -fif-conversion2 -ftree-ccp -ftree-dce -ftree-dominator-opts -ftree-dse -ftree-ter -ftree-lrs -ftree-sra -ftree-copyrename -ftree-fre -ftree-ch -fmerge-constants -fomit-frame-pointer -fthread-jumps -fcrossjumping -foptimize-sibling-calls -fcse-follow-jumps -fcse-skip-blocks -fgcse -fgcse-lm -fexpensive-optimizations -fstrength-reduce -frerun-cse-after-loop -frerun-loop-opt -fcaller-saves -fforce-mem -fpeephole2 -fschedule-insns -fschedule-insns2 -fsched-interblock -fsched-spec -fregmove -fstrict-aliasing -fdelete-null-pointer-checks -freorder-blocks -freorder-functions -funit-at-a-time -falign-functions -falign-jumps -falign-loops -falign-labels -ftree-pre -finline-functions -funswitch-loops -fgcse-after-reload"
  oflags="-O3"
  ;;
f95)
  gflags='-g'
  oflags='-O'
  if [ $( uname ) = SunOS ]; then
    gflags='-g -w4 -u -C'
    oflags='-fast'
  fi
  ;;
*)
  echo "Error: no Fortran 95 compiler found"
  exit
esac

# Host
machine=$HOSTNAME
if   [ "${machine:0:2}" = ds ]; then machine=datastar
elif [ "${machine:0:2}" = tg ]; then machine=teragrid
elif [ "$machine" = master ];   then machine=babieca
fi
ppn=1
rate=30000
case $machine in
  datastar) ppn=8 ;;
  teragrid) ppn=2 ;;
  babieca)  ppn=2 ;;
esac

# Compute nodes
[ $ppn -gt $np ] && ppn=$np
nodes=$(( np / ppn + ( np % ppn > 0 ? 1 : 0 ) ))

# RAM and Wall time usage
floatsize=4
nvars=21
ram=$(( nn / np * floatsize * nvars / 1024 / 1024 ))
#wt=$(( nt * nn / np / rate + 1 )) # old bash can only handle 32 bits
wt=$( echo $nt $nn $np $rate | awk '{ printf "%d", $1 * $2 / $3 / $4 + 1 }' )
hh=$(( wt / 3600 ))
mm=$(( wt % 3600 / 60 ))
ss=$(( wt % 60 ))
[ $hh -ge 1 ] && ss=0
wt=$( echo $hh $mm $ss | awk '{ printf "%d:%02d:%02d\n", $1, $2, $3 }' )
echo "Machine: $machine"
echo "RAM usage: at least ${ram}Mb"
echo "Wall time: $wt"

# Wall time limit
rate=$(( rate * 2 / 3 ))
#wt=$(( nt * nn / np / rate + 1 )) # old bash can only handle 32 bits
wt=$( echo $nt $nn $np $rate | awk '{ printf "%d", $1 * $2 / $3 / $4 + 1 }' )
hh=$(( wt / 3600 ))
mm=$(( wt % 3600 / 60 ))
ss=$(( wt % 60 ))
[ $hh -ge 1 ] && ss=0
wt=$( echo $hh $mm $ss | awk '{ printf "%d:%02d:%02d\n", $1, $2, $3 }' )

#------------------------------------------------------------------------------#
# Compile Fortran

# Source files
common="\\
  globals.f90 \\
  diffcn.f90 \\
  diffnc.f90 \\
  hourglasscn.f90 \\
  hourglassnc.f90 \\
  surfnormals.f90 \\
  bc.f90 \\
  zone.f90 \\
  inread.f90 \\
  setup.f90 \\
  arrays.f90 \\
  optimize.f90 \\
  gridgen.f90 \\
  material.f90 \\
  momentsource.f90 \\
  fault.f90 \\
  checkpoint.f90 \\
  output.f90 \\
  pml.f90 \\
  stress.f90 \\
  acceleration.f90 \\
  locknodes.f90 \\
  timestep.f90 \\
  sord.f90"
serial="\\
  serial.f90 \\
  serialio.f90"
mpi="\\
  mpi.f90 \\
  mpiio.f90"
mpi="\\
  mpi.babieca.f90 \\
  mpiio.babieca.f90"

case $fflags in
  O) fflags=$oflags ;;
  g) fflags=$gflags ;;
esac

# Write makefile
cat << END > tmp
FC = $fc
PFC = $pfc
FFLAGS = $fflags
COMMON = $common
SERIAL = $serial
MPI = $mpi
VPATH = f
fsord: makefile \$(SERIAL) \$(COMMON)
	cd f; \$(FC) \$(FFLAGS) \$(SERIAL) \$(COMMON) -o ../fsord
	sh/tarball
psord: makefile \$(MPI) \$(COMMON)
	cd f; \$(PFC) \$(FFLAGS) \$(MPI) \$(COMMON) -o ../psord
	sh/tarball
clean:
	rm -f tmp f/*.o f/*.mod f/*.ipo
realclean: clean
	rm -f makefile fsord psord
.PHONY: clean realclean
END
[ ! -f makefile ] && touch makefile
[ "$( diff tmp makefile )" != "" ] && mv tmp makefile
rm -f tmp

# Compile
if [ $compile ]; then
case $mode in
  serial)   gmake fsord; cp fsord $rundir ;;
  parallel) gmake psord; cp psord $rundir ;;
esac
fi
echo ''

# SDX
echo "cd $srcdir" > m/srcdir.m
echo "cd $rundir" > m/rundir.m
echo "addpath $srcdir/m" > m/viz.m
cat << END > viz
#!/bin/bash -e
matlab -nodesktop -nosplash -r "addpath $srcdir/m"
END
chmod u+x viz

#------------------------------------------------------------------------------#
# Save source
cp 'sord.tgz' $rundir
cd $rundir

# Write metadata
perl -e 'print pack('V',1) eq pack('L',1) ? "l\n":"b\n"' > endian
cat << END > runmeta.m
login   = '$LOGNAME';
name    = '$( finger $LOGNAME | sed -n 's/^.*e: //p' )';
rundate = '$( date )';
rundir  = '$rundir';
machine = '$machine';
host    = '$HOSTNAME';
os      = '$( uname -a )';
END

# Create output folders
[ -e checkpoint ] || mkdir checkpoint
[ -e stats ]      || mkdir stats
i=0
while [ $i -lt $nout ]; do
  i=$(( i + 1 ))
  dir=$( echo $i | awk '{ printf "%02d", $1 }' )
  [ -e $dir ] || mkdir $dir
done

#------------------------------------------------------------------------------#
# Run

case $machine in

datastar) #--------------------------------------#

if [ $( pwd | grep -v gpfs ) ]; then
  echo "jobs must be run from /gpfs"
  exit
fi

# Batch
opts="-tasks_per_node $ppn -nodes $nodes -rmpool 1 -euilib us -euidevice sn_all"
cat << END > batchjob
#!/bin/bash
#@environment = COPY_ALL;\\
#AIXTHREAD_COND_DEBUG=OFF;\\
#AIXTHREAD_MUTEX_DEBUG=OFF;\\
#AIXTHREAD_RWLOCK_DEBUG=OFF;\\
#AIXTHREAD_SCOPE=S;\\
#MP_ADAPTER_USE=dedicated;\\
#MP_CPU_USE=unique;\\
#MP_CSS_INTERRUPT=no;\\
#MP_EAGER_LIMIT=64K;\\
#MP_EUIDEVELOP=min;\\
#MP_LABELIO=no;\\
#MP_POLLING_INTERVAL=100000;\\
#MP_PULSE=0;\\
#MP_SHARED_MEMORY=yes;\\
#MP_SINGLE_THREAD=no;\\
#RT_GRQ=ON;\\
#SPINLOOPTIME=0;\\
#YIELDLOOPTIME=0;
#@ class = normalM
#@ node = $nodes
#@ tasks_per_node = $ppn
#@ wall_clock_limit = $wt
#@ node_usage = not_shared
#@ network.MPI = sn_all, shared, US
#@ job_type = parallel
#@ job_name = job.sord
#@ output = out.log
#@ error = err.log
#@ notification = always
#@ notify_user = $LOGNAME
#@ initialdir = $rundir
#@ queue
cd $rundir
poe ./psord $opts
END
chmod u+x batchjob

# Interactive
if [ "$run" -a $HOSTNAME != ds100 ]; then
  echo "interactive jobs must be launched from dspoe"
  exit
fi
case $mode$run in
  seriali)   ./fsord ;;
  serialg)   totalview poe -a ./fsord $opts ;;
  serialb)   nohup ./fsord > errors & ;;
  paralleli) poe ./psord $opts ;;
  parallelg) totalview poe -a ./psord $opts ;;
  parallelb) nohup poe ./psord $opts > errors & ;;
esac

;;

teragrid) #--------------------------------------#

if [ $( pwd | grep -v gpfs ) ]; then
  echo "jobs must be run from /gpfs"
  exit
fi

# Batch
cat << END > batchjob
#!/bin/bash
#PBS -q dque
#PBS -N sord_job
#PBS -l nodes=$nodes:ppn=$ppn
#PBS -l walltime=$wt
#PBS -o out.log
#PBS -e err.log
#PBS -V
cd $rundir
mpirun -v -machinefile \$PBS_NODEFILE -np $np ./psord
END
chmod u+x batchjob

# Interactive
if [ "$run" -a ${HOSTNAME:0:5} != 'tg-c1' ]; then
  echo "interactive jobs must be launched from tg-c127, 128, 129 or 130"
  exit
fi
[ -f machinefile ] || cat << END > machinefile
tg-c127:2
tg-c128:2
tg-c129:2
tg-c130:2
END
case $mode$run in
  seriali)   ./fsord ;;
  serialg)   gdb ./fsord ;;
  serialb)   nohup ./fsord > errors & ;;
  paralleli) mpirun -v -machinefile machinefile -np $np ./psord ;;
  parallelb)
    nohup mpirun -v -machinefile machinefile -np $np ./psord > errors &
    ;;
esac
tail +$(( nodes + 1 )) machinefile > tmp
head -$nodes machinefile >> tmp
mv tmp machinefile

;;

babieca) #--------------------------------------#

# Batch
cat << END > batchjob
#!/bin/bash
#PBS -q workq
#PBS -N sord_job
#PBS -l nodes=$nodes:ppn=$ppn:mpi
#PBS -o out.log
#PBS -e err.log
#PBS -V
sleep 2
cd $rundir
mpiexec -n $np ./psord
END
chmod u+x batchjob

# Interactive
[ -f machinefile ] || cat << END > machinefile
node37:2
node38:2
node39:2
node40:2
node41:2
node42:2
node43:2
node44:2
node45:2
node46:2
node47:2
node48:2
END
case $mode$run in
  seriali)   mpirun -machinefile machinefile ./fsord ;;
  serialg)   mpirun -machinefile machinefile -dbg=gdb ./fsord ;;
  serialb)   nohup mpirun -machinefile machinefile ./fsord > errors & ;;
  paralleli) mpirun -machinefile machinefile -np $np ./psord ;;
  parallelg) mpirun -machinefile machinefile -np $np -dbg=gdb ./psord ;;
  parallelb) nohup mpirun -machinefile machinefile -np $np ./psord > errors &;;
esac
tail +$(( nodes + 1 )) machinefile > tmp
head -$nodes machinefile >> tmp
mv tmp machinefile

;;

*) #--------------------------------------#

[ "$mode" = parallel ] && mpich2version &> /dev/null && ! mpdtrace &> /dev/null && mpd --daemon

# Interactive
case $mode$run in
  seriali)   ./fsord ;;
  serialg)   ddd ./fsord ;;
  serialb)   nice nohup ./fsord > errors & ;;
  paralleli) mpiexec -np $np ./psord ;;
  parallelg) mpiexec -gdb -np $np ./psord ;;
  parallelb) nice nohup mpiexec -np $np ./psord > errors & ;;
esac

;;

esac #--------------------------------------#

if [ "$run" = b ]; then
  echo "#!/bin/bash" > cancel.sh
  echo "kill $!" >> cancel.sh
  chmod u+x cancel.sh
fi

