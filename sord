#!/bin/bash -e

echo "SORD setup"
starttime=$(date)

# Get command line options
mode=guess
optimize=O
setup=yes
run=
while getopts spibgGnm:df opt; do
case "$opt" in
  s) mode=s ;;
  p) mode=p ;;
  i) run=i ;;
  b) run=b ;;
  g) optimize=g ;;
  G) optimize=g; run=g ;;
  n) setup= ; run= ;;
  m) machine="$OPTARG" ;;
  d) rm -rf out/* ;;
  f) rm -rf tmp/* ;;
  *) exit ;;
esac
done
shift $(( OPTIND - 1 ))

# Email address
email="$LOGNAME"
[ -f email ] && email="$( cat email )"

# Symlink input file specified on command line
if [ "$1" ]; then 
  infile="$1"
  if [ ! -f "$infile" ]; then
    echo "Error: $infile not found"
    exit 1
  fi
  ln -sf "$infile" 'in.m'
  infile=$( readlink 'in.m' 2> /dev/null ) || infile='in.m'
fi
mkdir -p tmp

# Locations
srcdir=$( /bin/pwd )
count=$( echo out/[0-9][0-9] | sed 's/.*\///' )
[ "$count" = '[0-9][0-9]' ] && count=00
count=$( echo $count | awk '{ printf "%02d", $1+1 }' )
echo "$count" > tmp/count

# Prepare input file
cat 'in/defaults.m' 'in.m' | sed "
s/%.*$//;
s/;/\\
/g;
" | sed "
s/[]{}='	[]/ /g;
s/  */ /g;
s/^ //;
s/ $//;
/^$/d
" > tmp/input

# Read input
nout=0
while read key params; do
set -- $params
case "$key" in
  nt) nt=$1 ;;
  nn) nm3=( $1 $2 $3 ) ;;
  np) np3=( $1 $2 $3 ) ;;
  out) nout=$(( nout + 1 )) ;;
  dx)   echo "$1" > tmp/dx ;;
  npml) echo "$1" > tmp/npml ;;
  timeseries) nout=$(( nout + 1 )) ;;
  datadir) datadir="$1" ;;
  return) break ;;
esac
done < tmp/input

[ "$run" -a "$run" != q ] && interactive=yes

# Host
if [ "$machine" ]; then :
elif [ "${HOSTNAME:0:2}" = ds ]; then machine=datastar
elif [ "${HOSTNAME:0:2}" = tg ]; then machine=teragrid
elif [ "$HOSTNAME" = master ];   then machine=babieca
else machine=$HOSTNAME
fi

# Machine attributes
maxnodes=1; maxcpus=1; maxram=800; maxmm=0; rate=200
case $machine in
  wide)                   maxcpus=2; maxram=1800 ;;
  phim)                              maxram=2800;  rate=200 ;;
  altai)                  maxcpus=8; maxram=30000; rate=90  ;; 
  babieca)  maxnodes=36;  maxcpus=2; maxram=800;   rate=80 ;;
  teragrid) maxnodes=252; maxcpus=2; maxram=3000;  rate=500; maxmm=1080 ;;
  datastar) maxnodes=265; maxcpus=8; maxram=13500; maxmm=1080 ;;          
esac
echo "Machine: $machine"
echo "CPUs: $(( maxnodes * maxcpus ))"

# Number of processors
[ $mode = guess -a $(( maxnodes * maxcpus )) -eq 1 ] && mode=s
[ $mode = s ] && np3=( 1 1 1 )
np=$(( np3[0] * np3[1] * np3[2] ));
[ $mode = guess -a $np -eq 1 ] && mode=s
[ $mode = guess -a $np -gt 1 ] && mode=p
nodes=$(( np / maxcpus + ( np % maxcpus > 0 ? 1 : 0 ) ))
[ $nodes -gt $maxnodes ] && nodes=$maxnodes
ppn=$(( np / nodes + ( np % nodes > 0 ? 1 : 0 ) ))
cpus=$ppn
[ $cpus -gt $maxcpus ] && cpus=$maxcpus

# Domain size
nm3[0]=$(( nm3[0] / np3[0] + 2 + ( nm3[0] % np3[0] > 0 ? 1 : 0 ) ))
nm3[1]=$(( nm3[1] / np3[1] + 2 + ( nm3[1] % np3[1] > 0 ? 1 : 0 ) ))
nm3[2]=$(( nm3[2] / np3[2] + 2 + ( nm3[2] % np3[2] > 0 ? 1 : 0 ) ))
nm=$( echo ${nm3[*]} | awk '{ print $1 * $2 * $3 }' )

# RAM and Wall time usage
floatsize=4
nvars=20 # oplevel 1-2
nvars=23 # oplevel 3-5
nvars=44 # oplevel 6
ram=$( echo $ppn $nm $nvars $floatsize | awk '{ printf "%.0f", $1 * ( $2 * $3 * $4 / 1024 / 1024 + 15 ) }' )
sus=$( echo $nt $ppn $nm $cpus $rate $nodes $maxcpus | awk '{ printf "%.0f", ( $1 + 2 ) * $2 * $3 / $4 / $5 / 3600000 * $6 * $7 }' )
mm=$(  echo $nt $ppn $nm $cpus $rate | awk '{ printf "%.0f", ( $1 + 2 ) * $2 * $3 / $4 / $5 / 40000 + 10 }' )
[ $maxmm -gt 0 -a $mm -gt $maxmm ] && mm=$maxmm
hh=$(( mm / 60 ))
mm=$(( mm % 60 ))
walltime=$( echo $hh $mm | awk '{ printf "%d:%02d:00", $1, $2 }' )
echo "Processes: $np"
echo "Memory usage: ${ram}Mb per node"
echo "Wall time limit: $walltime"
echo "SUs: $sus"
[ $ppn -gt $maxcpus ] && echo "Warning: exceding available CPUs per node ($maxcpus)"
[ $ram -gt $maxram ]  && echo "Warning: exceding available RAM per node (${maxram}Mb)"

[ "$setup" ] || exit 0

#------------------------------------------------------------------------------#

# Compiler
IFS=":$IFS"
for dir in $PATH; do
for file in xlf95_r ifort pgf90 gfortran f95; do
  if [ -x $dir/$file ]; then
    sfc=$file
    break 2
  fi
done
done
pfc='mpif90'
case $sfc in
xlf95_r)
  sfc='xlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg'
  pfc='mpxlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg'
  gflags='-p -g -C -qflttrap -qsigtrap -qlanglvl=95pure'
  oflags='-O -qmaxmem=-1'
  oflags='-O5'
  ;;
ifort)
  gflags='-O0 -p -g -CB -warn -traceback -u'
  oflags='-fast'
  [ $machine = teragrid ] && oflags='-O3'
  ;;
pgf90)
  gflags='-g -Mprof=lines'
  gflags='-O0 -g -Ktrap=fp -Mbounds -Mdclchk'
  oflags='-fast'
  ;;
gfortran)
  gflags='-O0 -pg -g -Wall -pedantic -fimplicit-none -fbounds-check -ffpe-trap=invalid,zero,overflow'
  oflags='-O3'
  ;;
f95)
  gflags='-g'
  oflags='-O'
  if [ $( uname ) = SunOS ]; then
    gflags='-g -w4 -u -C'
    oflags='-fast'
  fi
  ;;
*)
  echo "Error: no Fortran 95 compiler found"
  exit
esac
case $optimize in
  O) fflags=$oflags ;;
  g) fflags=$gflags ;;
esac

# Source files
base="
  globals.f90
  diffcn.f90
  diffnc.f90
  hourglass.f90
  bc.f90
  surfnormals.f90
  outprops.f90
  util.f90"
serial="
  serial.f90"
parallel="
  mpi.f90"
common="
  inread.f90
  setup.f90
  arrays.f90
  gridgen.f90
  output.f90
  momentsource.f90
  material.f90
  fault.f90
  metadata.f90
  resample.f90
  checkpoint.f90
  timestep.f90
  stress.f90
  acceleration.f90
  locknodes.f90
  sord.f90"

# Compile
cd f
case $mode in
  s) fc="$sfc"; collective="$serial" ;;
  p) fc="$pfc"; collective="$parallel" ;;
esac
make="$fc $fflags -o $srcdir/tmp/sord-$mode $base $collective $common"
echo "$make" > "$srcdir/tmp/state"
cat $base $collective $common >> "$srcdir/tmp/state" 
compile=yes
if [ -f "$srcdir/tmp/state-$mode" ]; then
  compile=$( cmp "$srcdir/tmp/state" "$srcdir/tmp/state-$mode" || : )
fi
if [ "$compile" ]; then
  rm -f "$srcdir/tmp/state-$mode"
  echo $make
  $make
  mv "$srcdir/tmp/state" "$srcdir/tmp/state-$mode"
fi
cd "$srcdir"

#------------------------------------------------------------------------------#
# Set-up and run

# Setup run directory
sh/tarball
rundir="out/$count"
echo "Run directory: $rundir"
mkdir -p out
mkdir "$rundir"
echo "$starttime: Start SORD setup" >> "$rundir/log"
cp 'in.m' tmp/sord.tgz tmp/sord-$mode tmp/input "$rundir"
if [ $optimize = g ]; then
  cp f/*.f90 "$rundir"
  chmod a-w "$rundir"/*.f90
fi
cd "$rundir"
rundir=$( /bin/pwd )
mkdir stats
mkdir checkpoint
mkdir debug
i=0
while [ $i -lt $nout ]; do
  i=$(( i + 1 ))
  dir=$( echo $i | awk '{ printf "%02d", $1 }' )
  mkdir $dir
done
if [ "$datadir" ]; then
  endian="$( perl -e 'print pack('V',1) eq pack('L',1) ? "l" : "b"' )"
  cd "$srcdir/$datadir"
  if [ "$endian" != "$( cat endian )" ]; then
    echo "Error: endian missmatch in data dir"
    exit 1
  fi
  datadir=$( /bin/pwd )
  cd "$rundir"
  ln -s "$datadir" 'data'
fi

# Write run metadata
cat << END > runmeta.m
% SORD run metadata
  login   = '$LOGNAME';
  name    = '$( finger $LOGNAME | sed -n 's/^.*e: //p' )';
  rundate = '$( date )';
  rundir  = '$rundir';
  infile  = '$infile';
  machine = '$machine';
  host    = '$HOSTNAME';
  os      = '$( uname -a )';
  mode    = '$mode';
  np      = $np;
END

# Run script
case "$mode" in
s) cat << END > run
#!/bin/bash -e
echo "\$(date): Start SORD run" >> log
case \${1:?} in
  -i) ./sord-s ;;
  -g) ddd ./sord-s ;;
  -b) nice nohup ./sord-s > out.log & :; pid=\$!
      echo "Background job started with PID \$pid" >> log
      echo "Background job started with PID \$pid" ;;
esac
echo "\$(date): Finished!" >> log
END
;;
p) cat << END > run
#!/bin/bash -e
mpich2version &> /dev/null && ! mpdtrace &> /dev/null && mpd --daemon
echo "\$(date): Start SORD run" >> log
case \${1:?} in
  -i) mpiexec -np $np ./sord-p ;;
  -g) mpiexec -gdb -np $np ./sord-p ;;
  -b) nice nohup mpiexec -np $np ./sord-p > out.log & :; pid=\$!
      echo "Background job started with PID \$pid" >> log
      echo "Background job started with PID \$pid" ;;
esac
echo "\$(date): Finished!" >> log
END
;;
esac
chmod u+x run

# Machine dependent run scripts
case $machine in
datastar) . "$srcdir/sh/datastar" ;;
teragrid) . "$srcdir/sh/teragrid" ;;
babieca)  . "$srcdir/sh/babieca"  ;;
esac

echo "$(date): Finished setup" >> log

# Launch job
[ "$run" ] && ./run "-$run"

