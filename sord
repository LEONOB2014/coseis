#!/bin/bash -e
#------------------------------------------------------------------------------#

echo -e "\nSORD setup"

# Get command line options
mpi=guess
debug=no
debugger=no
compile=yes
run=yes
matlab=no
deleteout=no
while getopts spgGcnmd opt; do
  case $opt in
    s) mpi=no ;;
    p) mpi=yes ;;
    g) debug=yes ;;
    G) debug=yes; debugger=yes ;;
    c) run=no ;;
    n) run=no; compile=no ;;
    m) matlab=yes ;;
    d) deleteout=yes ;;
  esac
done
shift $(( OPTIND - 1 ))

# Copy input file specified on command line
[ -n "$1" ] && cp -f "$1" 'in.m'

# Strip MATLAB caracters
sed "s/%.*$//; s/;/;\n/g; s/[]={}';[]*//g;/^$/d" 'defaults.m' 'in.m' > tmp

# Read input
nout=0
while read key params; do
  set -- $params
  case "$key" in
    nt)  nt=$1 ;;
    nn)  nn3=( $1 $2 $3 ) ;;
    np)  np3=( $1 $2 $3 ) ;;
    out) nout=$(( nout + 1 )) ;;
  esac
done < tmp

# Create output folders
[ $deleteout == yes ] && rm -rf out
[ -e out ]       || mkdir out
[ -e out/ckp ]   || mkdir out/ckp
[ -e out/stats ] || mkdir out/stats
i=0
while [ $i -lt $nout ]; do
  i=$(( i + 1 ))
  dir=$( echo $i | awk '{ printf "out/%02d", $1 }' )
  [ -e $dir ] || mkdir $dir
done
rm -f batchjob f/mpif.h

# Problem size
nn=$(( nn3[0] * nn3[1] * nn3[2] ));
np=$(( np3[0] * np3[1] * np3[2] ));
[ $matlab = yes ] && np=1

#------------------------------------------------------------------------------#
# Metadata

osname=$( uname )

# Identify machine
if   [ "${HOSTNAME:0:2}" = ds ]; then machine="datastar"
elif [ "${HOSTNAME:0:2}" = tg ]; then machine="teragrid"
elif [ "$HOSTNAME" = master ];   then machine="babieca"
else machine=$HOSTNAME
fi

# Save source, input files & byte order
./tarball
cp sord.tgz out/
cp 'defaults.m' out/
cp 'in.m' out/
perl -e 'print pack('V',1) eq pack('L',1) ? "little\n":"big\n"' > out/endian

# RAM usage and run time estimate
floatsize=4
nvars=21
ram=$(( nn / np * floatsize * nvars / 1024 / 1024 ))
rate=250000
[ $matlab = yes ] && rate=70000
wt=$(( nt * nn / np / rate + 1 ))
hh=$(( wt / 3600 ))
mm=$(( wt % 3600 / 60 ))
ss=$(( wt % 60 ))
[ $hh -ge 1 ] && ss=0
wt=$( echo $hh $mm $ss | awk '{ printf "%d:%02d:%02d\n", $1, $2, $3 }' )
echo "RAM usage: at least ${ram}Mb"
echo "Run time: at least $wt"

# Write metadata
cat << END > out/runmeta.m
login = '$LOGNAME' ;
name = '$( finger $LOGNAME | sed -n 's/^.*e: //p' )' ;
date = '$( date )' ;
machine = '$machine' ;
host = '$HOSTNAME' ;
os = '$( uname -a )' ;
END

#------------------------------------------------------------------------------#
# Matlab backend

if [ $matlab = yes ]; then

cat << END > batchjob
#!/bin/bash -e
unset DISPLAY
nohup matlab -r "sord, quit" > out.log &
END
chmod u+x batchjob

[ $run = yes ] && matlab -nodesktop -nosplash -r sord

exit

fi

#------------------------------------------------------------------------------#
# Fortran backend

# Common routines
SRC="\\
  f/globals.f90 \\
  f/diffcn.f90 \\
  f/diffnc.f90 \\
  f/hourglasscn.f90 \\
  f/hourglassnc.f90 \\
  f/surfnormals.f90 \\
  f/zone.f90 \\
  f/inread.f90 \\
  f/setup.f90 \\
  f/arrays.f90 \\
  f/optimize.f90 \\
  f/gridgen.f90 \\
  f/material.f90 \\
  f/momentsource.f90 \\
  f/fault.f90 \\
  f/checkpoint.f90 \\
  f/output.f90 \\
  f/pml.f90 \\
  f/stress.f90 \\
  f/acceleration.f90 \\
  f/locknodes.f90 \\
  f/timestep.f90 \\
  f/sord.f90"

[ $mpi = guess -a $np -eq 1 ] && mpi=no
[ $mpi = guess -a $np -gt 1 ] && mpi=yes

# Defaults
case $mpi in
no)  FC="f95";    SRC="f/serial.f90 f/serialio.f90 $SRC" ;;
yes) FC="mpif90"; SRC="f/mpi.f90 f/mpiio.f90 $SRC" ;;
esac
case $debug in
no)  FFLAGS="-O" ;;
yes) FFLAGS="-g" ;;
esac

# OS specific
case $osname in
Linux)
  case $mpi in
  no)  FC="gfortran" ;;
  yes) FC="mpif90"
  ;;
  esac
  case $debug in
  no)  FFLAGS="-O3" ;;
  yes) FFLAGS="-g -W -pedantic -std=f95 -fimplicit-none" ;;
  esac
  ;;
SunOS)
  case $debug in
  no)  FFLAGS="-fast" ;;
  yes) FFLAGS="-g -w4 -u -C" ;;
  esac
  ;;
esac

# Machine specific
case $machine in
datastar)
  case $mpi in
  no)  FC="xlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg" ;;
  yes) FC="mpxlf95_r -qsuffix=f=f90 -q64 -qsuppress=cmpmsg" ;;
  esac 
  case $debug in
  no)  FFLAGS="-O3 -qstrict -qarch=pwr4 -qtune=pwr4" ;;
  yes) FFLAGS="-g -C -qflttrap -qsigtrap -qlanglvl=95pure" ;;
  esac
  ;;
teragrid)
  case $mpi in
  no)  FC="ifort" ;;
  yes) FC="mpif90" ;;
  esac
  case $debug in
  no)  FFLAGS="-fast" ;;
  yes) FFLAGS="-g -CB -warn -traceback" ;;
  esac
  ;;
babieca)
  case $mpi in
  no)  FC="pgf95" ;;
  yes) FC="mpif90" ;;
  esac
  ;;
esac

# If using MPICH, work around broken mpif90
if [ "$FC" = mpif90 ]; then
  mpidir=$( dirname $( dirname $( which mpif90 ) ) )
  echo cp $mpidir/include/mpif.h f/
  cp $mpidir/include/mpif.h f/
fi

# Write makefile
cat << END > tmp
FC = $FC
FFLAGS = $FFLAGS
SRC = $SRC
fsord: \$(SRC) makefile
	\$(FC) \$(FFLAGS) \$(SRC) -o fsord
END

# Compile SORD
[ ! -f makefile ] && touch makefile
[ "$( diff tmp makefile )" != "" ] && mv tmp makefile
rm -f tmp
[ $compile = yes ] && gmake
rm -f *.mod f/mpif.h

#------------------------------------------------------------------------------#
# Machine specific batch submission and run commands

case $machine in

datastar) #--------------------------------------#

cat << END
Datastar 8-way, p655+ nodes
run from a subdirectory of /gpfs/
dspoe.sdsc.edu: inpteractive
  4GB?, 40proc?, 2hr limit
dslogin.sdsc.edu: compiling and batch submition
  3672GB, 2176proc, 18hr limit
  llsubmit batchjob
other useful commands:
  llcancel <jobID>
  llq
  llq -s <jobID>
  show_q
  show_bf # backfill openings
  reslist # check allocation
END
[ $( pwd | grep -v gpfs ) ] || exit

# Batch
rate=100000
wt=$(( nt * nn / np / rate + 1 ))
hh=$(( wt / 3600 ))
mm=$(( wt % 3600 / 60 ))
ss=$(( wt % 60 ))
[ $hh -ge 1 ] && ss=0
wt=$( echo $hh $mm $ss | awk '{ printf "%d:%02d:%02d\n", $1, $2, $3 }' )
ppn=8;
[ $ppn -gt $np ] && ppn=$np
nodes=$(( np / ppn + ( np % ppn > 0 ? 1 : 0 ) ))
opts="-tasks_per_node $ppn -nodes $nodes -rmpool 1 -euilib us -euidevice sn_all"
rundir=$( /bin/pwd )
cat << END > batchjob
#!/bin/bash
#@ environment = COPY_ALL;\\
AIXTHREAD_COND_DEBUG=OFF;\\
AIXTHREAD_MUTEX_DEBUG=OFF;\\
AIXTHREAD_RWLOCK_DEBUG=OFF;\\
AIXTHREAD_SCOPE=S;\\
MP_ADAPTER_USE=dedicated;\\
MP_CPU_USE=unique;\\
MP_CSS_INTERRUPT=no;\\
MP_EAGER_LIMIT=64K;\\
MP_EUIDEVELOP=min;\\
MP_EUIDEVICE=sn_single;\\
MP_EUILIB=us;\\
MP_POLLING_INTERVAL=100000;\\
MP_PULSE=0;\\
MP_SHARED_MEMORY=yes;\\
MP_SINGLE_THREAD=no;\\
RT_GRQ=ON;\\
SPINLOOPTIME=0;\\
YIELDLOOPTIME=0;
#@ wall_clock_limit = $wt
#@ class = normal
#@ node_usage = not_shared
#@ notify_user = $LOGNAME
#@ node = $nodes
#@ tasks_per_node = $ppn
#@ job_type = parallel
#@ network.MPI = sn_single,not_shared,US,HIGH
#@ notification = always
#@ job_name = job.dfm
#@ output = out.log
#@ error = err.log
#@ initialdir = $rundir
#@ queue
cd $rundir
poe ./fsord $opts
END
chmod u+x batchjob

# Interactive
if [ $( hostname ) != ds100 ]; then
  echo "login to dspoe.sdsc.edu to run interactively"
  run=no
fi
case $run$debugger$mpi in
  yesnono)   ./fsord ;;
  yesnoyes)  poe ./fsord $opts ;;
  yesyesno)  totalview poe -a ./fsord $opts ;;
  yesyesyes) totalview poe -a ./fsord $opts ;;
esac

;;

teragrid) #--------------------------------------#

cat << END
configureing for Teragrid
batch submission:
qsub batchjob
END

# Batch
rate=100000
wt=$(( nt * nn / np / rate + 1 ))
hh=$(( wt / 3600 ))
mm=$(( wt % 3600 / 60 ))
ss=$(( wt % 60 ))
[ $hh -ge 1 ] && ss=0
wt=$( echo $hh $mm $ss | awk '{ printf "%d:%02d:%02d\n", $1, $2, $3 }' )
ppn=2;
[ $ppn -gt $np ] && ppn=$np
nodes=$(( np / ppn + ( np % ppn > 0 ? 1 : 0 ) ))
cat << END > batchjob
#!/bin/bash
#PBS -q dque
#PBS -N sord_job
#PBS -l nodes=$nodes:ppn=$ppn
#PBS -l walltime=$wt
#PBS -o out.log
#PBS -e err.log
#PBS -V
cd $rundir
time mpirun -v -machinefile \$PBS_NODEFILE -np $np ./fsord
END
chmod u+x batchjob

# Interactive
case $run$debugger$mpi in
  yesnono)   ./fsord ;;
  yesyesno)  gdb ./fsord ;;
  yesyesyes) time mpirun -v -machinefile \$PBS_NODEFILE -np $np ./fsord ;;
esac

;;

babieca) #--------------------------------------#

# Info
cat << END
configuring for babieca
batch submission (up to 19 procs):
qsub batchjob
other useful commands: pbsnodes -a, pingd, qstat, qdel
END

# Batch
ppn=2
[ $ppn -gt $np ] && ppn=$np
nodes=$(( np / ppn + ( np % ppn > 0 ? 1 : 0 ) ))
cat << END > batchjob
#!/bin/bash
#PBS -q workq
#PBS -N sord_job
#PBS -l nodes=$nodes:ppn=$ppn
#PBS -o out.log
#PBS -e err.log
#PBS -V
sleep 2
cd $rundir
time mpiexec -np $np ./fsord
END
chmod u+x batchjob

# Interactive
case $run$debugger$mpi in
  yesnono)   ./fsord ;;
  yesyesno)  gdb ./fsord ;;
  yesnoyes)  mpiexec -np $np ./fsord ;;
  yesyesyes) mpiexec -np $np -dbg=gdb ./fsord ;;
esac

;;

*) #--------------------------------------#

# Batch
case $mpi in
  no)  cmd="" ;;
  yes) cmd="mpirun -np $np" ;;
esac
cat << END > batchjob
#!/bin/bash
nohup $cmd ./fsord > out.log &
END
chmod u+x batchjob

# Interactive
case $run$debugger$mpi in
  yesnono)   ./fsord ;;
  yesyesno)  ddd ./fsord ;;
  yesnoyes)  mpirun -np $np ./fsord ;;
  yesyesyes) mpirun -np $np -dbg=ddd ./fsord ;;
esac

;;

esac #--------------------------------------#
