#!/bin/bash -e

while getopts ncfgmpdbB opt; do
  case $opt in
  n) dryrun="yes" ;;
  c) compilecode="yes" ;;
  f) recompile="yes" ;;
  g) debug="yes" ;;
  m) forcempi="yes" ;;
  p) nompiio="yes" ;;
  d) deleteout="yes" ;;
  b) background="yes" ;;
  B) background="" ;;
  esac
done

[ -e out -a "$deleteout" = "yes" ] && rm -r out
[ -e out ] || mkdir out

if [ "$background" = "yes" ]; then
  "$0" "$@" -B < /dev/null >& log &
  echo "kill -INT $!" > cancel.sh; chmod u+x cancel.sh
  echo "SORD running in background, for progress type:"
  echo "cat log; tail -0f log"
  exit
fi
echo "SORD - Support Opperator Rupture Dynamics"
date
shift `expr $OPTIND - 1`

if [ "$compilecode$dryrun" = "" ]; then
  compilecode="yes"
  runcode="yes"
fi

rundir=`/bin/pwd`
infile="input"
[ -r "$infile" ] || exit

me="$0"
[ -f "$me" ] || me=`which "$0"`
if [ -L "$me" ]; then
  tmp=`ls -l "$me" | sed 's/^.*-> //'`
  [ ${tmp:0:1} = / ] || tmp="`dirname $me`/$tmp"
  me="$tmp"
fi
cd `dirname "$me"`
srcdir=`/bin/pwd`
srcbase=`basename "$srcdir"`
if [ "$srcdir" = "$rundir" ]; then
  echo "Error: please do not run SORD from the source code directory"
  exit
fi
cd "$rundir"

#cp "${srcdir}/readme_data" out/readme
#[ -f metadata.in ] || cp "${srcdir}/metadata_default" metadata.in
#cp metadata.in out/
#cp "$infile" out/

nout=0
while read key params; do
  set -- $params
  case "$key" in
  #*) ;;
  n)          n=( $1 $2 $3 $4 ) ;;
  parallel)   p=( $1 $2 $3 ) ;;
  checkpoint) [ -e out/ckp ] || mkdir out/ckp ;;
  out)      
    nout=$(( nout + 1 ))
    case $field in
    u) fields=3 ;;
    v) fields=3 ;;
    S) fields=6 ;;
    m) fields=1 ;;
    f) fields=3 ;;
    esac
    dir=$( echo $nout | awk '{ printf "out/%02d", $1 }' )
    [ -e $dir ] || mkdir $dir
    for (( i=1; i<=fields; i++ )); do
      dir=$( echo $nout $i | awk '{ printf "out/%02d/%1d", $1, $2 }' )
      [ -e $dir ] || mkdir $dir
    done
  esac
done < "$infile"

points=$(( n[1] * n[2] * n[3] ));
procs=$(( p[1] * p[2] * p[3] ));
ram=$(( points / procs * 4 * 23 / 1024 / 1024 ))
wt=$(( points / procs / 40000 + 1 ))
if [ $wt -gt 5400 ]; then wt="$(( wt / 3600 + 1 )):00:00"
elif [ $wt -gt 90 ]; then wt="$(( wt / 60 + 1 )):00"
fi
echo "Total points: $points"
echo "Processors: $procs"
echo "Ram per proc: $ram"
echo "Wall clock: $wt"


#------------------------------------------------------------------------------#

name=`finger $LOGNAME | sed -n 's/^.*e: //p'`
date=`date`
osname=`uname`
if [ "$PBS_DEFAULT" ];           then machine="teragrid"
elif [ "$osname" = "AIX" ];      then machine="datastar"
elif [ "$HOSTNAME" = "master" ]; then machine="babieca"
fi

case $machine in

#------------------#
teragrid)

ppn=2;
[ "$ppn" -gt "$procs" ] && ppn="$procs"
nodes=`echo $procs $ppn | awk '{ x = int($1/$2); print x + ($1>x*$2) }'`

cat <<- END > pbscript
	#!/bin/csh
	#PBS -q dque
	#PBS -N sord_job
	#PBS -l nodes=$nodes:ppn=$ppn
	#PBS -l walltime=$wt
	#PBS -o stdout
	#PBS -e stderr
	#PBS -V
	cd $rundir
END

if [ "$procs" = "1" ]; then
	echo "time ./sord_bin" >> pbscript
else
	echo "time mpirun -v -machinefile \$PBS_NODEFILE -np $procs ./sord_bin" >> pbscript
fi

cat <<- END > run.sh
	echo To submit job:
	echo qsub pbscript
END
;;

#------------------#
babieca)

ppn=2;
[ "$ppn" -gt "$procs" ] && ppn="$procs"
nodes=`echo $procs $procpernode | awk '{ x = int($1/$2); print x + ($1 > x*$2) }'`

cat <<- END > pbscript
	#!/bin/sh
	#PBS -q workq
	#PBS -N sord_job
	#PBS -l nodes=$nodes:ppn=$ppn
	#PBS -o stdout
	#PBS -e stderr
	#PBS -V
	sleep 2
	cd $rundir
END

if [ "$procs" = "1" ]; then
	echo "time ./sord_bin" >> pbscript
else
	echo "time mpiexec -np $procs ./sord_bin" >> pbscript
fi

cat <<- END > run.sh
	echo batch submission \\(up to 19 procs\\):
	echo qsub pbscript
	echo
	echo to run interactively \(you really should use the batch system\):
	echo mpirun -np $procs $rundir/sord_bin
	echo
	echo other useful commands: pbsnodes -a, pingd, qstat, qdel
END
;;

#------------------#
datastar)

ppn=8;
[ "$ppn" -gt "$procs" ] && ppn="$procs"
nodes=`echo $procs $ppn | awk '{ x = int($1/$2); print x + ($1>x*$2) }'`
cat <<- END > llscript
	#!/usr/bin/bash
	#@ environment = COPY_ALL;\\
	AIXTHREAD_COND_DEBUG=OFF;\\
	AIXTHREAD_MUTEX_DEBUG=OFF;\\
	AIXTHREAD_RWLOCK_DEBUG=OFF;\\
	AIXTHREAD_SCOPE=S;\\
	MP_ADAPTER_USE=dedicated;\\
	MP_CPU_USE=unique;\\
	MP_CSS_INTERRUPT=no;\\
	MP_EAGER_LIMIT=65536;\\
	MP_EUIDEVELOP=min;\\
	MP_EUIDEVICE=sn_single;\\
	MP_EUILIB=us;\\
	MP_POLLING_INTERVAL=100000;\\
	MP_PULSE=0;\\
	MP_SHARED_MEMORY=yes;\\
	MP_SINGLE_THREAD=$nompiio;\\
	RT_GRQ=ON;\\
	SPINLOOPTIME=0;\\
	YIELDLOOPTIME=0;
	#@ wall_clock_limit = $wt
	#@ class = normal
	#@ node_usage = not_shared
	#@ notify_user = $LOGNAME
	#@ node = $nodes
	#@ tasks_per_node = $ppn
	#@ job_type = parallel
	#@ network.MPI = sn_single,not_shared,US,HIGH
	#@ notification = always
	#@ job_name = job.dfm
	#@ output = stdout
	#@ error = stderr
	#@ initialdir = $rundir
	#@ queue
	cd $rundir
	poe ./sord_bin
END
cat <<- END > interactive.sh
	#!/usr/bin/bash
	if [ \`hostname\` != ds100 ]; then
	  echo "Error: you must be logged in to dspoe to run interactively"
	  exit
	fi
	poe ./sord_bin -tasks_per_node $ppn -nodes $nodes -rmpool 1 -euilib us -euidevice sn_single
	#totalview poe -a ./sord_bin -tasks_per_node $ppn -nodes $nodes -rmpool 1 -euilib us -euidevice sn_single
END
chmod u+x interactive.sh
cat <<- END > run.sh
	echo batch submition \\(up to 1408 procs, 2816 GB\\):
	echo llsubmit llscript
	echo
	echo run interactively \\(up to 32 procs, 64 GB\\):
	echo ssh dspoe
	echo ./interactive.sh
	echo
	echo other useful commands:
	echo llcancel \\<jobID\\>, llq, llq -s \\<jovID\\>, showq, reslist
END
if [ `pwd | grep -v gpfs` ]; then
	echo "Error: please run dfm from a subdirectory of /gpfs/"
	exit
fi
;;

#------------------#
*)

if [ "$debug" = "yes" ]; then
	if [ "$procs" = "1" -a "$forcempi" != "yes" ]; then
		echo "ddd ./sord_bin" > run.sh
	else
		echo "mpirun -dbg=ddd -np $procs ./sord_bin" > run.sh
	fi
else
	if [ "$procs" = "1" -a "$forcempi" != "yes" ]; then
		echo "time ./sord_bin" > run.sh
	else
		echo "time mpirun -np $procs ./sord_bin" > run.sh
	fi
fi
;;

esac

chmod u+x run.sh

#------------------------------------------------------------------------------#

cat << END | perl -e '
while (<>) {
  if( /\s*([^#]\S*)\s*=\s*(\S.*)/ ) {
    $key = $1;
    $val = $2;
    $fallback{$key} = $val
  }
}
#use Data::Dumper;
#print STDERR Dumper(\%fallback);
open( FILE, "metadata.in" );
while( <FILE> ) {
  if( /\s*([^#]\S*)\s*=\s*(.*)/ ) {
    $key = $1;
    $val = $2;
    if ( ! "$val" && $fallback{$key} ) { $val = $fallback{$key} }
    print "$key = $val\n";
  } else { print }
}
' > "out/metadata"
DC.publisher.Name = $name
DC.publisher.Email = ${LOGNAME}@${HOSTNAME}
DC.date.created = $date
DC.creator.Name = $name
DC.creator.Email = ${LOGNAME}@${HOSTNAME}
DC.contributor = $name
RunID.Submitter.Name = $name
RunID.Investigator.Name = $name
RunID.Date.Submitted = $date
SystemID.HostName = ${HOSTNAME}
SystemID.OS.Name = $osname
SystemID.OS.Version = `uname -r`
SystemID.OS.Description = `uname -a`
SystemID.Compiler.Name =
SystemID.Compiler.Version =
SystemID.Compiler.Description =
SystemID.NumberOfProcessors = $procs
ProgramInfo.Version.User = $date
PhysicalInputs.Volume.MaxX = ${L[1]}
PhysicalInputs.Volume.MaxY = ${L[2]}
PhysicalInputs.Volume.MaxZ = ${L[3]}
PhysicalInputs.TimeSeries.EndTime = ${L[4]}
NumericalInputs.InputFile.Name = $infile
NumericalInputs.TimeSeries.NumberOfSteps = ${n[4]}
NumericalInputs.TimeSeries.TimeIncrement = ${h[4]}
NumericalInputs.3DData.NumPointsXdirection = ${n[1]}
NumericalInputs.3DData.NumPointsYdirection = ${n[2]}
NumericalInputs.3DData.NumPointsZdirection = ${n[3]}
NumericalInputs.3DData.GridIncrement.Xdirection = ${h[1]}
NumericalInputs.3DData.GridIncrement.Ydirection = ${h[2]}
NumericalInputs.3DData.GridIncrement.Zdirection = ${h[3]}
END

#------------------------------------------------------------------------------#

cd "$srcdir"

FC="f95"
CC="cc"
OPTFLAGS="-O"
OBJECT="main.o input.o output.o step.o elastic.o fault.o"
if [ "$procs" != "1" -o "$forcempi" = "yes" ]; then
  FC="mpif95"
  CC="mpicc"
  OBJECT="$OBJECT mpisetup.o mpioutput.o"
fi
[ "$debug" = "yes" ] && OPTFLAGS="-g"
if [ "$osname" = "Linux" ]; then
  OPTFLAGS="-I$srcdir"
  OBJECT="$OBJECT gnutrapfpe.o"
  [ "$points" -gt 10000 ] && OPTFLAGS="-I$srcdir -O3"
  [ "$debug" = "yes" ]    && OPTFLAGS="-I$srcdir -g"
elif [ "$osname" = "SunOS" ]; then
  FC="f90"
  OPTFLAGS="-fast"
  [ "$debug" = "yes" ] && OPTFLAGS="-g"
elif [ "$machine" = "datastar" ]; then
  FC="mpxlf90_r"
  CC="mpcc_r"
  OPTFLAGS="-O3 -qstrict -qarch=pwr4 -qtune=pwr4 -q64"
  #OPTFLAGS="-O3 -qstrict -qarch=pwr3 -qtune=pwr3 -qcache=auto -bmaxdata:0x80000000 -bmaxstack:0x10000000"
  [ "$debug" = "yes" ] && OPTFLAGS="-g -qflttrap"
fi
[ "$machine" = "babieca" -a "$procs" = "1" -a "$forcempi" != "yes" ] && FC="pgf95"
cat << END > tmp
FC       = $FC
CC       = $CC
FFLAGS   = $OPTFLAGS
LDFLAGS  = $OPTFLAGS
OBJECT   = $OBJECT
sord_bin: \$(OBJECT)
	\$(FC) \$(OBJECT) -o sord_bin \$(LDFLAGS)
	./tarball.sh
\$(OBJECT): com.f makefile
clean:
	rm *.o
END
[ ! -f "makefile" ] && touch makefile
[ "`diff tmp makefile`" != "" ] && mv tmp makefile
[ "$recompile" = "yes" ] && make clean
[ "$compilecode" = "yes" ] && gmake

#------------------------------------------------------------------------------#

if [ "$runcode" = "yes" ]; then

cd "$rundir"
perl -e 'print pack('V',1) eq pack('L',1) ? "little\n":"big\n"' > out/endian
cp "${srcdir}/${srcbase}.tgz" out/
cp -f "${srcdir}/sord_bin" .
./run.sh || :
rm -f cancel.sh

fi

