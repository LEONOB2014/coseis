#!/bin/bash -e

while getopts ncfgmpdbB opt; do
  case $opt in
  n) dryrun=yes ;;
  c) compilecode=yes ;;
  f) recompile=yes ;;
  g) debug=yes ;;
  m) forcempi=yes ;;
  b) background=yes ;;
  B) background="" ;;
  esac
done

[ -e meta ] && rm -r meta
[ -e meta ] || mkdir meta

if [ "$background" = yes ]; then
  "$0" "$@" -B < /dev/null >& log &
  echo "kill -INT $!" > cancel.sh; chmod u+x cancel.sh
  echo "SORD running in background, for progress type:"
  echo "cat log; tail -0f log"
  exit
fi
echo "SORD - Support Opperator Rupture Dynamics"
date
shift $( expr $OPTIND - 1 )

if [ "$compilecode$dryrun" = "" ]; then
  compilecode=yes
  runcode=yes
fi

rundir=$( bin/pwd )
infile="in"
[ -r "$infile" ] || exit

me="$0"
[ -f "$me" ] || me=`which "$0"`
if [ -L "$me" ]; then
  tmp=`ls -l "$me" | sed 's/^.*-> //'`
  [ ${tmp:0:1} = / ] || tmp="$( dirname $me )/$tmp"
  me="$tmp"
fi
cd $( dirname "$me" )
srcdir=`/bin/pwd`
srcbase=$( basename "$srcdir" )
if [ "$srcdir" = "$rundir" ]; then
  echo "Error: please do not run SORD from the source code directory"
  exit
fi
cd "$rundir"

nout=0
while read key params; do
  set -- $params
  case "$key" in
  n)     n=( $1 $2 $3 $4 ) ;;
  nproc) p=( $1 $2 $3 ) ;;
  esac
done < "$infile"

floatsize=4
points=$(( n[1] * n[2] * n[3] ));
procs=$(( p[1] * p[2] * p[3] ));
ram=$(( points / procs * floatsize * 22 / 1024 / 1024 ))
wt=$(( points / procs / 40000 + 1 ))
if [ $wt -gt 5400 ]; then wt="$(( wt / 3600 + 1 )):00:00"
elif [ $wt -gt 90 ]; then wt="$(( wt / 60 + 1 )):00"
fi
echo "Total points: $points"
echo "Processors: $procs"
echo "Ram per proc: $ram"
echo "Wall clock: $wt"


#------------------------------------------------------------------------------#

name=`finger $LOGNAME | sed -n 's/^.*e: //p'`
date=`date`
osname=`uname`
if [ "$PBS_DEFAULT" ];           then machine="teragrid"
elif [ "$osname" = "AIX" ];      then machine="datastar"
elif [ "$HOSTNAME" = "master" ]; then machine="babieca"
fi

case $machine in

#------------------#
teragrid)

ppn=2;
[ "$ppn" -gt "$procs" ] && ppn="$procs"
nodes=`echo $procs $ppn | awk '{ x = int($1/$2); print x + ($1>x*$2) }'`

cat <<- END > submit.sh
	#!/bin/csh
	#PBS -q dque
	#PBS -N sord_job
	#PBS -l nodes=$nodes:ppn=$ppn
	#PBS -l walltime=$wt
	#PBS -o stdout
	#PBS -e stderr
	#PBS -V
	cd $rundir
END

if [ "$procs" = "1" ]; then
	echo "time ./sord_bin" >> submit.sh
else
	echo "time mpirun -v -machinefile \$PBS_NODEFILE -np $procs ./sord_bin" >> submit.sh
fi

cat <<- END > run.sh
	echo To submit job:
	echo qsub submit.sh
END
;;

#------------------#
babieca)

ppn=2
[ "$ppn" -gt "$procs" ] && ppn="$procs"
nodes=$(( procs / ppn + ( procs % ppn > 0 ? 1 : 0 ) ))

cat <<- END > submit.sh
	#!/bin/sh
	#PBS -q workq
	#PBS -N sord_job
	#PBS -l nodes=$nodes:ppn=$ppn
	#PBS -o stdout
	#PBS -e stderr
	#PBS -V
	sleep 2
	cd $rundir
END

if [ "$procs" = 1 ]; then
	echo "time ./sord_bin" >> submit.sh
else
	echo "time mpiexec -np $procs ./sord_bin" >> submit.sh
fi

cat <<- END > run.sh
	echo batch submission \\(up to 19 procs\\):
	echo qsub submit.sh
	echo
	echo to run interactively \(you really should use the batch system\):
	echo mpirun -np $procs $rundir/sord_bin
	echo
	echo other useful commands: pbsnodes -a, pingd, qstat, qdel
END
;;

#------------------#
datastar)

ppn=8;
[ "$ppn" -gt "$procs" ] && ppn="$procs"
nodes=$(( procs / ppn + ( procs % ppn > 0 ? 1 : 0 ) ))
cat <<- END > submit.sh
	#!/usr/bin/bash
	#@ environment = COPY_ALL;\\
	AIXTHREAD_COND_DEBUG=OFF;\\
	AIXTHREAD_MUTEX_DEBUG=OFF;\\
	AIXTHREAD_RWLOCK_DEBUG=OFF;\\
	AIXTHREAD_SCOPE=S;\\
	MP_ADAPTER_USE=dedicated;\\
	MP_CPU_USE=unique;\\
	MP_CSS_INTERRUPT=no;\\
	MP_EAGER_LIMIT=65536;\\
	MP_EUIDEVELOP=min;\\
	MP_EUIDEVICE=sn_single;\\
	MP_EUILIB=us;\\
	MP_POLLING_INTERVAL=100000;\\
	MP_PULSE=0;\\
	MP_SHARED_MEMORY=yes;\\
	MP_SINGLE_THREAD=$nompiio;\\
	RT_GRQ=ON;\\
	SPINLOOPTIME=0;\\
	YIELDLOOPTIME=0;
	#@ wall_clock_limit = $wt
	#@ class = normal
	#@ node_usage = not_shared
	#@ notify_user = $LOGNAME
	#@ node = $nodes
	#@ tasks_per_node = $ppn
	#@ job_type = parallel
	#@ network.MPI = sn_single,not_shared,US,HIGH
	#@ notification = always
	#@ job_name = job.dfm
	#@ output = stdout
	#@ error = stderr
	#@ initialdir = $rundir
	#@ queue
	cd $rundir
	poe ./sord_bin
END
cat <<- END > interactive.sh
	#!/usr/bin/bash
	if [ \`hostname\` != ds100 ]; then
	  echo "Error: you must be logged in to dspoe to run interactively"
	  exit
	fi
	poe ./sord_bin -tasks_per_node $ppn -nodes $nodes -rmpool 1 -euilib us -euidevice sn_single
	#totalview poe -a ./sord_bin -tasks_per_node $ppn -nodes $nodes -rmpool 1 -euilib us -euidevice sn_single
END
chmod u+x interactive.sh
cat <<- END > run.sh
	echo batch submition \\(up to 1408 procs, 2816 GB\\):
	echo llsubmit submit.sh
	echo
	echo run interactively \\(up to 32 procs, 64 GB\\):
	echo ssh dspoe
	echo ./interactive.sh
	echo
	echo other useful commands:
	echo llcancel \\<jobID\\>, llq, llq -s \\<jovID\\>, showq, reslist
END
if [ `pwd | grep -v gpfs` ]; then
	echo "Error: please run dfm from a subdirectory of /gpfs/"
	exit
fi
;;

#------------------#
*)

if [ "$debug" = "yes" ]; then
	if [ "$procs" = 1 -a "$forcempi" != yes ]; then
		echo "ddd ./sord_bin" > run.sh
	else
		echo "mpirun -dbg=ddd -np $procs ./sord_bin" > run.sh
	fi
else
	if [ "$procs" = 1 -a "$forcempi" != yes ]; then
		echo "time ./sord_bin" > run.sh
	else
		echo "time mpirun -np $procs ./sord_bin" > run.sh
	fi
fi
;;

esac

chmod u+x run.sh

#------------------------------------------------------------------------------#

$name
${LOGNAME}@${HOSTNAME}
$date
${HOSTNAME}
$osname
`uname -r`
`uname -a`
$procs
$date

#------------------------------------------------------------------------------#

cd "$srcdir"

FC="f95"
CC="cc"
OPTFLAGS="-O"
OBJECT="main.o input.o output.o step.o elastic.o fault.o"
if [ "$procs" != "1" -o "$forcempi" = "yes" ]; then
  FC="mpif95"
  CC="mpicc"
  OBJECT="$OBJECT mpisetup.o mpioutput.o"
fi
[ "$debug" = "yes" ] && OPTFLAGS="-g"
if [ "$osname" = "Linux" ]; then
  OPTFLAGS="-I$srcdir"
  OBJECT="$OBJECT gnutrapfpe.o"
  [ "$points" -gt 10000 ] && OPTFLAGS="-I$srcdir -O3"
  [ "$debug" = "yes" ]    && OPTFLAGS="-I$srcdir -g"
elif [ "$osname" = "SunOS" ]; then
  FC="f90"
  OPTFLAGS="-fast"
  [ "$debug" = "yes" ] && OPTFLAGS="-g"
elif [ "$machine" = "datastar" ]; then
  FC="mpxlf90_r"
  CC="mpcc_r"
  OPTFLAGS="-O3 -qstrict -qarch=pwr4 -qtune=pwr4 -q64"
  #OPTFLAGS="-O3 -qstrict -qarch=pwr3 -qtune=pwr3 -qcache=auto -bmaxdata:0x80000000 -bmaxstack:0x10000000"
  [ "$debug" = "yes" ] && OPTFLAGS="-g -qflttrap"
fi
[ "$machine" = "babieca" -a "$procs" = "1" -a "$forcempi" != "yes" ] && FC="pgf95"
cat << END > tmp
FC       = $FC
CC       = $CC
FFLAGS   = $OPTFLAGS
LDFLAGS  = $OPTFLAGS
OBJECT   = $OBJECT
sord_bin: \$(OBJECT)
	\$(FC) \$(OBJECT) -o sord_bin \$(LDFLAGS)
	./tarball.sh
\$(OBJECT): com.f makefile
clean:
	rm *.o
END
[ ! -f "makefile" ] && touch makefile
[ "`diff tmp makefile`" != "" ] && mv tmp makefile
[ "$recompile" = "yes" ] && make clean
[ "$compilecode" = "yes" ] && gmake

#------------------------------------------------------------------------------#

if [ "$runcode" = yes ]; then

cd "$rundir"
perl -e 'print pack('V',1) eq pack('L',1) ? "little\n":"big\n"' > meta/endian
cp "${srcdir}/${srcbase}.tgz" meta/
cp -f "${srcdir}/sord_bin" .
./run.sh || :
rm -f cancel.sh

fi

