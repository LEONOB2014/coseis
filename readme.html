<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.6: http://docutils.sourceforge.net/" />
<title>SORD</title>
<style type="text/css">

body {
    margin: 0px;
    color: #000;
    background-color: #fff;
    font-family: 'Lucida Grande', Geneva, Verdana, sans-serif;
}

div {
    margin: 0px;
}

div.line-block {
    margin: 20px;
    margin-top: 10px;
    margin-bottom: 10px;
}

div.footer {
    margin: 20px;
    margin-top: 40px;
}

p {
    margin: 20px;
    margin-top: 15px;
    margin-bottom: 15px;
}

dl {
    margin: 20px;
    margin-top: 35px;
    margin-bottom: 15px;
}

table {
    margin: 60px;
    margin-top: 0px;
    margin-bottom: 0px;
    border: none;
}

td {
    border: none;
}

pre {
    margin: 60px;
    margin-top: 15px;
    margin-bottom: 15px;
}

h1 {
    margin: 0px;
    padding: 20px;
    border-top: medium solid #700;
    border-bottom: medium solid #300;
    font-weight: lighter;
    color: #fff;
    background-color: #600;
    text-shadow: #000 3px 3px 3px;
}

h2, h3, h4 {
    padding: 5px;
    margin: 15px;
    margin-top: 20px;
    margin-bottom: 10px;
    background-color: #eee;
}

a {
    color: #00c;
    text-decoration: none;
}

a:hover, a:active {
    color: #66f;
    text-decoration: none;
}

img {
    border: 15px solid #fff;
    padding: 0px;
}


</style>
</head>
<body>
<div class="document" id="sord">
<h1 class="title">SORD</h1>

<a class="reference external image-reference" href="http://earth.usc.edu/~gely/ely-saf-surface.mov"><img align="right" alt="doc/ely-saf-surface.jpg" class="align-right" src="doc/ely-saf-surface.jpg" /></a>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#summary" id="id2">Summary</a><ul>
<li><a class="reference internal" href="#license" id="id3">License</a></li>
<li><a class="reference internal" href="#author" id="id4">Author</a></li>
</ul>
</li>
<li><a class="reference internal" href="#publications" id="id5">Publications</a></li>
<li><a class="reference internal" href="#system-requirements" id="id6">System requirements</a></li>
<li><a class="reference internal" href="#installation" id="id7">Installation</a></li>
<li><a class="reference internal" href="#user-guide" id="id8">User Guide</a><ul>
<li><a class="reference internal" href="#quick-test" id="id9">Quick test</a></li>
<li><a class="reference internal" href="#scripting-with-python" id="id10">Scripting with Python</a></li>
<li><a class="reference internal" href="#running-jobs" id="id11">Running jobs</a></li>
<li><a class="reference internal" href="#field-i-o" id="id12">Field I/O</a></li>
<li><a class="reference internal" href="#boundary-conditions" id="id13">Boundary Conditions</a></li>
<li><a class="reference internal" href="#defining-the-fault-rupture-surface" id="id14">Defining the fault rupture surface</a></li>
</ul>
</li>
<li><a class="reference internal" href="#memory-usage-and-scaling" id="id15">Memory Usage and Scaling</a></li>
<li><a class="reference internal" href="#development" id="id16">Development</a><ul>
<li><a class="reference internal" href="#debugging" id="id17">Debugging</a></li>
<li><a class="reference internal" href="#profiling" id="id18">Profiling</a></li>
<li><a class="reference internal" href="#source-control" id="id19">Source control</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="summary">
<h3>Summary</h3>
<p>The Support Operator Rupture Dynamics (SORD) code simulates spontaneous rupture
within a 3D isotropic viscoelastic solid.  Wave motions are computed on a
logically rectangular hexahedral mesh, using the generalized finite difference
method of support operators.  Stiffness and viscous hourglass corrections are
employed to suppress suppress zero-energy grid oscillation modes.  The fault
surface is modeled by coupled double nodes, where the strength of the coupling
is determined by a linear slip-weakening friction law.  External boundaries may
be reflective or absorbing, where absorbing boundaries are handled using the
method of perfectly matched layers (PML).  The hexahedral mesh can accommodate
non-planar ruptures and surface topography</p>
<p>SORD simulations are configured with Python scripts.  Underlying computations
are coded in Fortran 95 and parallelized for multi-processor execution using
Message Passing Interface (MPI).  The code is portable and tested with a
variety of Fortran 95 compilers, MPI implementations, and operating systems
(Linux, Mac OS X, IBM AIX, SUN Solaris).</p>
<div class="section" id="license">
<h4>License</h4>
<p>SORD is open-source and released under the <a class="reference external" href="license.txt">GNU General Public License Version 3</a>.  You are free to use or redistribute the code, with the
obligation that you contribute back any modification or derived works.</p>
</div>
<div class="section" id="author">
<h4>Author</h4>
<div class="line-block">
<div class="line"><a class="reference external" href="http://earth.usc.edu/~gely/">Geoffrey Ely</a></div>
<div class="line"><a class="reference external" href="http://www.usc.edu/dept/earth/">Department of Earth Sciences</a></div>
<div class="line"><a class="reference external" href="http://www.usc.edu/">University of Southern California</a></div>
<div class="line"><a class="reference external" href="http://earth.usc.edu/~gely/">http://earth.usc.edu/~gely/</a></div>
<div class="line"><a class="reference external" href="mailto:gely&#37;&#52;&#48;usc&#46;edu">gely<span>&#64;</span>usc<span>&#46;</span>edu</a></div>
</div>
</div>
</div>
<div class="section" id="publications">
<h3>Publications</h3>
<p>The first two papers give (for wave propagation and spontaneous rupture,
respectively) the formulation, numerical algorithm, and verification of the
SORD method. The third paper presents an application to simulating earthquakes
in southern California.</p>
<p class="ref">Ely, G. P., S. M. Day, and J.-B. Minster (2008),
<em>A support-operator method for visco-elastic wave modeling in 3D heterogeneous media</em>,
Geophys. J. Int., <a class="reference external" href="http://www.blackwell-synergy.com/doi/abs/10.1111/j.1365-246X.2007.03633.x">172(1), 331-344</a>,
doi: 10.1111/j.1365-246X.2007.03633.x.
<a class="reference external" href="http://earth.usc.edu/~gely/pub/ely-som-20080426.pdf">[PDF]</a></p>
<p class="ref">Ely, G. P., S. M. Day, and J.-B. Minster (2009),
<em>A support-operator method for 3D rupture dynamics</em>,
Geophys. J. Int.,
<a class="reference external" href="http://www3.interscience.wiley.com/journal/122267744/abstract">177(3), 1140-1150</a>,
doi:10.1111/j.1365-246X.2009.04117.x.
<a class="reference external" href="http://earth.usc.edu/~gely/pub/ely-sord-20090504.pdf">[PDF]</a></p>
<p class="ref">Ely, G. P., S. M. Day, and J.-B. Minster (2010),
<em>Dynamic rupture models for the southern San Andreas fault</em>,
BSSA, 100(1).
<a class="reference external" href="http://earth.usc.edu/~gely/pub/ely-saf-20090721.pdf">[PDF]</a>
<a class="reference external" href="http://earth.usc.edu/~gely/ely-saf-esupp.html">[Electronic supplement]</a></p>
</div>
<div class="section" id="system-requirements">
<h3>System requirements</h3>
<ul class="simple">
<li>Fortran 95 compiler.</li>
<li><a class="reference external" href="http://www.python.org/download/">Python</a>, and
<a class="reference external" href="http://http://numpy.scipy.org/">NumPy</a> (Numerical Python).</li>
<li>(Optional) Message Passing Interface (MPI) library.  Required for
multi-core processing.</li>
<li>(Optional) <a class="reference external" href="http://matplotlib.sourceforge.net/">Matplotlib</a>, <a class="reference external" href="http://www.scipy.org/">SciPy</a>, and Pyproj Python packages.  Required for
supplemental plotting, signal processing, and mesh generation utilities.</li>
<li>(Optional) <a class="reference external" href="http://bazaar.canonical.com/">Bazaar</a> version control system.
Useful for SORD development and staying updated with the latest code version.</li>
</ul>
</div>
<div class="section" id="installation">
<h3>Installation</h3>
<p>Fortran and MPI installation should only be necessary for laptops and
workstations.  HPC systems generally supply specifically tuned Fortran
compilers and MPI libraries.</p>
<ol class="arabic">
<li><p class="first">GNU Fortran is recommended if you don't already have a Fortran 95 compiler.</p>
<p>Fedora/Red Hat Linux:</p>
<pre class="literal-block">
sudo yum install gfortran
</pre>
<p>Ubuntu Linux:</p>
<pre class="literal-block">
sudo apt-get install gfortran
</pre>
<p>Mac OS X:</p>
<blockquote>
<p>First install either the iPhone or the Mac-only version of <a class="reference external" href="http://developer.apple.com/technology/xcode.html">Xcode</a> available from Apple
Developer Connection (free <a class="reference external" href="http://connect.apple.com">membership</a> required).
Then install the GNU Fortran version available from the <a class="reference external" href="http://r.research.att.com/tools">R for Mac OS X
Developer's Page</a> (versions from MacPorts
and Fink seem to be problematic and are not recommended).</p>
</blockquote>
</li>
<li><p class="first"><a class="reference external" href="http://www.mcs.anl.gov/research/projects/mpich2/">MPICH2</a> is recommended
if you need MPI.  The following shell script installs MPICH2:</p>
<blockquote>
<p><a class="reference external" href="install/install-mpich.sh">install-mpich.sh</a></p>
</blockquote>
</li>
<li><p class="first">It is recommended that you install a private copy of Python for SORD.  The
following script installs Python and NumPy:</p>
<blockquote>
<p><a class="reference external" href="install/install-python.sh">install-python.sh</a></p>
</blockquote>
<p><a class="reference external" href="http://www.enthought.com/products/epddownload.php">Enthought Python Distribution</a> (EPD) is another
option that includes many bells and whistles such as the <a class="reference external" href="http://code.enthought.com/projects/mayavi">Mayavi</a> visualization package.</p>
</li>
<li><p class="first">Download the SORD source code.  The best option is use Bazaar version
control, which facilitates applying code updates, and merging local
modifications (see <a class="reference internal" href="#source-control">Source Control</a> section for examples). The following
script installs Bazaar, SORD, and
<a class="reference external" href="http://earth.usc.edu/~gely/cvm/readme.html">SCEC CVM4</a>.</p>
<blockquote>
<p><a class="reference external" href="install/install-sord.sh">install-sord.sh</a></p>
</blockquote>
<p>Alternatively, download and unpack the source tar archive from here:</p>
<blockquote>
<p><a class="reference external" href="http://earth.usc.edu/~gely/sord/sord.tgz">http://earth.usc.edu/~gely/sord/sord.tgz</a></p>
</blockquote>
</li>
<li><p class="first">For laptop and workstation installations, the default system configuration
is usually be adequate.  To test the default configuration:</p>
<pre class="literal-block">
cd sord/
python configure.py
</pre>
<p>Systems with batch schedulers (such as PBS or LoadLeveler) generally require
custom configuration to specify system resources, compiler options, and
scheduler scripts.  If SORD has already been configured for your system you can
use one of the included configurations.  For example, for the TeraGrid Ranger
system at TACC:</p>
<pre class="literal-block">
python configure.py tacc-ranger
</pre>
<p>To see the list of included configurations look in the <tt class="docutils literal">conf/</tt> directory.
Each custom configuration is located in a separate sub-directory.  To create a
new custom configuration, make a new sub-directory following the example of
the supplied configurations.</p>
</li>
<li><p class="first">Compile the code and setup the Python path by running:</p>
<pre class="literal-block">
python setup.py
python setup.py path
</pre>
</li>
</ol>
</div>
<div class="section" id="user-guide">
<h3>User Guide</h3>
<div class="section" id="quick-test">
<h4>Quick test</h4>
<p>Run a simple point source explosion test and plot a 2D slice of particle
velocity:</p>
<pre class="literal-block">
cd scripts/example
python sim.py -i
python plot.py
</pre>
<p>Plotting requires Matplotlib, and the result should look like this:</p>
<blockquote>
<img alt="doc/example.png" src="doc/example.png" />
</blockquote>
</div>
<div class="section" id="scripting-with-python">
<h4>Scripting with Python</h4>
<p>For a simple example consider the above test, <a class="reference external" href="scripts/example/sim.py">scripts/example/sim.py</a>:</p>
<pre class="literal-block">
#!/usr/bin/env python
import sord                               # import the sord module
delta = 100.0, 100.0, 100.0, 0.0075       # step length in (x, y, z, t)
shape = 61, 61, 61, 60                    # mesh size in (x, y, z, t)
fieldio = [                               # field variable input and output
    ( '=',  'rho', [], 2670.0 ),          # material density
    ( '=',  'vp',  [], 6000.0 ),          # material P-wave velocity
    ( '=',  'vs',  [], 3464.0 ),          # material S-wave velocity
    ( '=',  'gam', [], 0.3    ),          # material viscosity
    ( '=w', 'v1',  [0,0,31,-1], 'vx' ),   # write X velocity slice output
    ( '=w', 'v2',  [0,0,31,-1], 'vy' ),   # write Y velocity slice output
]
ihypo = 31.0, 31.0, 31.0                  # source location
source = 'potency'                        # source type
source1 = 1e6, 1e6, 1e6                   # source normal components
source2 = 0.0, 0.0, 0.0                   # source shear components
timefunction = 'brune'                    # source time function
period = 6 * delta[3]                     # source dominant period
sord.run( locals() )                      # launch SORD job


</pre>
<p>Every script starts by importing the <tt class="docutils literal">sord</tt> module.  SORD parameters are
specified as local variables that are passed to the <tt class="docutils literal">sord.run()</tt> function by
the <tt class="docutils literal">locals()</tt> built-in Python function.  A complete list of possible SORD
parameters and default values are specified in <a class="reference external" href="parameters.py">parameters.py</a>.</p>
<p>The Python language gives a powerful way to construct SORD input.  For example,
it may be desirable to specify the total simulation time, and divide by <tt class="docutils literal">dt</tt>
to determine the number of time steps:</p>
<pre class="literal-block">
T = 100.0            # total time temporary variable
nt = int( T / dt )   # number of time steps
</pre>
<p>The <tt class="docutils literal">T</tt> variable is not a valid SORD parameter; it is only sued for temporary
storage.  Variables with single single character names or names ending with an
underscore, are ignored by <tt class="docutils literal">sord.run()</tt>, so may be safely used for temporary
storage.  More elaborate example scripts can be found in the <tt class="docutils literal">scripts</tt>
directory.</p>
</div>
<div class="section" id="running-jobs">
<h4>Running jobs</h4>
<p>Each time <tt class="docutils literal">sord.run()</tt> is called, a run directory is created at the location
set by the <tt class="docutils literal">rundir</tt> parameter (<tt class="docutils literal">tmp/</tt> in this case).  The directory
contains the executable and scripts to run the code, and will contain all of
the generated output and metadata.  From the run directory, start the job
interactively with the <tt class="docutils literal">run.sh</tt> script:</p>
<pre class="literal-block">
tmp/run.sh
</pre>
<p>Or, submit the job to the batch system with the <tt class="docutils literal">queue.sh</tt> script</p>
<pre class="literal-block">
tmp/queue.sh
</pre>
<p>Output (and large input, such as the material model) is stored in flat binary
binary files.  Statistic, such as peak acceleration and peak velocity, are
computed periodically during each run and stored in the <tt class="docutils literal">stats/</tt> directory.</p>
</div>
<div class="section" id="field-i-o">
<h4>Field I/O</h4>
<p>Multidimensional field arrays can be accessed for input and output through the
<tt class="docutils literal">fieldio</tt> list.  The <a class="reference external" href="fieldnames.py">fieldnames.py</a> file specifies the list of available
field variables, which are categorized in four ways: (1) static vs. dynamic,
(2) settable vs. output only, (3) node vs. cell registration, and (4) volume
vs. fault surface.  For example, density <tt class="docutils literal">rho</tt> is a static, settable, cell,
volume variable.  Slip path length <tt class="docutils literal">sl</tt> is a dynamic, output, node, fault
variable.  The <tt class="docutils literal">fieldio</tt> list is order dependent with subsequent inputs
overwriting previous inputs.  So, for example, a field may be assigned to one
value for the entire volume, followed by a different value for a sub-region of
the volume.</p>
<p>All field I/O operations require slice indices <tt class="docutils literal">[j,k,l,t]</tt>, which specify a
four-dimensional sub-volume of the array in space and time.  Array indexing
starts at 1 for the first node, and 1.5 for the first cell.  Negative indices
count inward from end of the array, starting at -1 for the last node, and -1.5
for the last cell.  Indices can be either a single index, a range <tt class="docutils literal">(start,
end)</tt>, or a strided range <tt class="docutils literal">(start, end, step)</tt>.  Empty parentheses <tt class="docutils literal">()</tt> are
shorthand for a full range.  Empty brackets <tt class="docutils literal">[]</tt> are shorthand for the entire
4D volume.  Some examples of slice notation:</p>
<pre class="literal-block">
[10, 20, 1, (1,-1)]       # Single node, full time history
[10.5, 20.5, 1.5, ()]     # Single cell, full time history
[2, (), (), (1,-1,10)]    # j=2 node surface, every 10th time step
[(), (), (), -1]          # Full 3D volume, last time step
[]                        # Entire 4D volume
</pre>
<p>Each member of the <tt class="docutils literal">fieldio</tt> list contains a mode, a field name, and slice
indices, followed by mode dependent parameters.  The following I/O modes are
available, where <tt class="docutils literal">'f'</tt> is the field variable name (from the list
<a class="reference external" href="fieldnames.py">fieldnames.py</a>), and <tt class="docutils literal">[]</tt> are the slice indices:</p>
<pre class="literal-block">
('=',   'f', [], val),             # Set f to value
('+',   'f', [], val),             # Add value to f
('=s',  'f', [], val),             # Set f to random numbers in range (0, val)
('=f',  'f', [], val, tfunc, T),   # Set f to time function with period T, scaled by val
('=r',  'f', [], filename),        # Read from filename into f
('=R',  'f', [], filename),        # Read from filename into f with exrapolation.
('=w',  'f', [], filename),        # Write f to filename
('=wi', 'f', [], filename),        # Write weighted average of f to filename.
</pre>
<p>A letter <tt class="docutils literal">'i'</tt> in the mode indicates sub-cell positioning via weighted
averaging.  In this case the spatial indices are single logical coordinates
that may vary continuously over the range.  The fractional part of the index
determines the weights.  For example, an index of 3.2 to the 1D variable f
would specify the weighted average: 0.8 * f(3) + 0.2 * f(4).</p>
<p>Reading and writing to disk uses flat binary files where j is the fastest
changing index, and t is the slowest changing index.  Mode 'R' extrapolates any
singleton dimensions to fill the entire array.  This is useful for reading 1D
or 2D models into 3D simulations, obviating the need to store (possibly very
large) 3D material and mesh coordinate files.</p>
<p>All input modes may use '+' instead of '=' to add to, rather than replace,
preexisting values.  For a list of available time functions, see the
<tt class="docutils literal">time_function</tt> subroutine in <a class="reference external" href="src/util.f90">src/util.f90</a>.  The routine can be easily
modified to add new time functions.  Time functions can be offset in time with
the <tt class="docutils literal">tm0</tt> initial time parameter.</p>
</div>
<div class="section" id="boundary-conditions">
<h4>Boundary Conditions</h4>
<p>Boundary conditions for the six faces of the model domain are specified by the
parameters <tt class="docutils literal">bc1</tt> (near-size, x, y, and z faces) and <tt class="docutils literal">bc2</tt> (far-side, x, y,
and x faces).  The symmetry boundary conditions can be use to reduce
computations for problems where they are applicable.  These are not used for
specifying internal slip boundaries. However, for problems with symmetry across
a slip surface, the fault may be placed at the boundary and combined with an
anti-mirror symmetry condition.  The following BC types are supported:</p>
<p><strong>Type 0</strong>: Vacuum free-surface.  Stress is zero in cells outside the boundary.</p>
<blockquote>
<img alt="doc/bc0.png" src="doc/bc0.png" />
</blockquote>
<p><strong>Type 3</strong>: Rigid surface. Displacement is zero at the boundary.</p>
<blockquote>
<img alt="doc/bc3.png" src="doc/bc3.png" />
</blockquote>
<p><strong>Type 1</strong>: Mirror symmetry at the node.  Normal displacement is zero at the
boundary.  Useful for a boundary corresponding to (a) the plane orthogonal to
the two nodal planes of a double-couple point source, (b) the plane normal to
the mode-III axis of a symmetric rupture, or (c) the zero-width axis of a 2D
plane strain problem.</p>
<blockquote>
<img alt="doc/bc1.png" src="doc/bc1.png" />
</blockquote>
<p><strong>Type -1</strong>: Anti-mirror symmetry at the node.  Tangential displacement is zero
at the boundary.  Useful for a boundary corresponding to (a) the nodal planes
of a double-couple point source, (b) the plane normal to the mode-II axis of a
symmetric rupture, or (c) the zero-width axis of a 2D antiplane strain problem.</p>
<blockquote>
<img alt="doc/bc-1.png" src="doc/bc-1.png" />
</blockquote>
<p><strong>Type 2</strong>: Mirror symmetry at the cell. Same as type 1, but centered on the cell.</p>
<blockquote>
<img alt="doc/bc2.png" src="doc/bc2.png" />
</blockquote>
<p><strong>Type -2</strong>: Anti-mirror symmetry at the cell.  Same as type -1, but centered
on the cell.  Can additionally be used when the boundary corresponds to the
slip surface of a symmetric rupture.</p>
<blockquote>
<img alt="doc/bc-2.png" src="doc/bc-2.png" />
</blockquote>
<p><strong>Type 10</strong>: Perfectly match layer (PML) absorbing boundary.</p>
<p>Example: a 3D problem with a free surface at Z=0, and PML absorbing boundaries
on all other boundary faces:</p>
<pre class="literal-block">
nn  = 50, 50, 50
bc1 = 10, 10,  0
bc2 = 10, 10, 10
</pre>
<p>Example: a 2D antiplane strain problem with PML absorbing boundaries.  The
number of nodes is 2 for the zero-width axis:</p>
<pre class="literal-block">
nn  = 50, 50,  2
bc1 = 10, 10, -1
bc2 = 10, 10, -1
</pre>
</div>
<div class="section" id="defining-the-fault-rupture-surface">
<h4>Defining the fault rupture surface</h4>
<p>Fault rupture always follows a surface of the (possibly non-planar) logical
mesh.  The orientation of the fault plane is defined by the <tt class="docutils literal">faultnormal</tt>
parameter.  This can be either 1, 2, or 3 corresponding to surfaces normal to
the j, k, or l logical mesh directions. Any other value (typically 0) disables
rupture altogether. The location of the rupture plane with in the mesh is
determined by the <tt class="docutils literal">ihypo</tt> parameter, which has a dual purpose of also
defining the nucleation point. So, the indices of the collocated fault double
nodes are given by <tt class="docutils literal">int(ihypo(faultnormal))</tt>, and <tt class="docutils literal">int(ihypo(faultnormal)) +
1</tt>. For example, a 3D problem of dimensions 200.0 x 200.0 x 200.0, with a
fault plane located at z = 100.0, and double nodes at l = (21, 22), may be set
up as such:</p>
<pre class="literal-block">
dx = 5.0
faultnormal = 3
ihypo = 21, 21, 21.5
nn  = 41, 41, 42
bc1 = 0, 0, 0
bc2 = 0, 0, 0
</pre>
<p>For problems with symmetry across the rupture surface (where mesh and material
properties are mirror images), the symmetry may be exploited for computational
savings by using an appropriate boundary condition and solving the elastic
equations for only one side of the fault.  In this case, the fault double nodes
must lie at the model boundary, and the and the cell-centered anti-mirror
symmetry condition used.  For example, reducing the size of the previous
example to put the rupture surface along the far z boundary:</p>
<pre class="literal-block">
nn = 41, 41, 22
bc2 = 0, 0, -2
</pre>
<p>Alternatively, put the rupture surface along the near z boundary:</p>
<pre class="literal-block">
ihypo = 21, 21, 1.5
nn = 41, 41, 22
bc1 = 0, 0, -2
bc2 = 0, 0, 0
</pre>
<p>Further symmetries may present. If our previous problem has slip only in the
x direction, then we may also use node-centered mirror symmetry along the in-plane
axis, and node-centered anti-mirror symmetry along the anti-plane axis, to reduce
computations eight-fold:</p>
<pre class="literal-block">
ihypo = 21, 21, 21.5
nn = 21, 21, 22
bc1 = 0, 0, 0
bc2 = -1, 1, -2
</pre>
</div>
</div>
<div class="section" id="memory-usage-and-scaling">
<h3>Memory Usage and Scaling</h3>
<p>For rectilinear meshes, 23 single precision (four-byte) memory variables are
required per mesh point.  Curvilinear meshes have two options with a trade-off
in memory usage vs. floating-point operations.  Stored operators require 44
variables per mesh point and give the best performance, while on-the-fly
operators require 23 variables per mesh point at the cost of a factor of four
increase in floating point operations.  As CPU improvement tends to out-pace
memory bandwidth improvement, in the future, on-the-fly operators may become
faster than stored operators.  The operator type is controlled by the
<tt class="docutils literal">oplevel</tt> parameter, but can generally be left alone, as the default is to
automatically detect rectilinear and curvilinear meshes and assign the proper
operator type for fastest performance.</p>
<p>On current hardware, computation time is on the order of the one second per
time step per one million mesh points.  SORD scalability has been benchmarked
up to 16 thousand processors at the TACC Ranger facility.  The following chart
is the wall-time per step for 8 million mesh points per core (click for PDF):</p>
<a class="reference external image-reference" href="doc/sord-benchmark-ranger.pdf"><img alt="doc/sord-benchmark-ranger.png" src="doc/sord-benchmark-ranger.png" /></a>
<p>This benchmark tests computation only. For many applications, disk output is
the primary bottleneck and will limit scalability.  When configuring domain
decomposition, it is important to minimize the number of cores accessing a
particular file.  For example, if output is required for the entire ground
surface, maximizing the number of domain partitions in the vertical direction
will minimize the number of cores participating in I/O.</p>
</div>
<div class="section" id="development">
<h3>Development</h3>
<p>Suggestions for improvements, and contributions to the SORD code and
documentation are greatly appreciated.</p>
<div class="section" id="debugging">
<h4>Debugging</h4>
<p>The <tt class="docutils literal">debug</tt> input parameter is useful for finding problems, and can take the
following values:</p>
<blockquote>
<p><strong>0</strong>: Debugging off.</p>
<p><strong>1</strong>: Verbose status output.</p>
<p><strong>2</strong>: Synchronize multiple processors. This is useful for tracking down MPI
related bugs.</p>
<p><strong>3</strong>: Dump field variable output in text files at every step. Only do this
for small tests or you will fill up your disk!</p>
</blockquote>
<p>During testing, compiler checks, such as array overflow and floating-point
exceptions, can be turned on with the <tt class="docutils literal"><span class="pre">-t</span></tt> or <tt class="docutils literal"><span class="pre">--testing</span></tt> option.
Additionally, to compile and run under a debugger use the <tt class="docutils literal"><span class="pre">-g</span></tt> or
<tt class="docutils literal"><span class="pre">--debugging</span></tt> option.  Naturally, these options depend on the capabilities of
the particular compiler.  The specific flags passed to the compiler can be
configured by editing <tt class="docutils literal">conf.py</tt>.</p>
</div>
<div class="section" id="profiling">
<h4>Profiling</h4>
<p>Internal code timings, for benchmarking performance, are collected and saved to
the <tt class="docutils literal">prof/</tt> directory.  The file format is flat binary that can be examined
with the UNIX command <tt class="docutils literal">od <span class="pre">-f</span></tt>.  Eight categories are timed for every time
iteration step, and save in the following files:</p>
<blockquote>
<p><strong>1time</strong>: Time integration subroutine.</p>
<p><strong>2stress</strong>: Stress subroutine.</p>
<p><strong>3accel</strong>: Acceleration subroutine, including multiprocessor halo swapping
communications.</p>
<p><strong>4stats</strong>: Statistics subroutine, including multiprocessor min/max reductions.</p>
<p><strong>5ckpt</strong>: Checkpoint subroutine.</p>
<p><strong>6mp</strong>: Aggregate of all multiprocessor operations, including halo swap,
global reductions, and parallel I/O.</p>
<p><strong>7io</strong>: Aggregate of all input and output operations, including checkpointing
and field I/O.</p>
<p><strong>8step</strong>: Total for complete time iteration.</p>
</blockquote>
<p>Profiling can be very difficult to interpret for multiprocessor runs.  Timing
is only saved for the master processor.  It can be helpful to synchronize the
processors using <tt class="docutils literal">debug = 2</tt> to give more accurate relative timing values.</p>
<p>Additionally, SORD can be run with compiler generated code profiling using the
<tt class="docutils literal"><span class="pre">-p</span></tt> or <tt class="docutils literal"><span class="pre">--profiling</span></tt> option.</p>
</div>
<div class="section" id="source-control">
<h4>Source control</h4>
<p>We use <a class="reference external" href="http://bazaar.canonical.com/">Bazaar</a> for version control. Some examples:</p>
<p>Apply any recent updates from the repository, overwriting any local changes.
This is a way to keep up-to-date with the latest code.</p>
<pre class="literal-block">
bzr pull
bzr revert
</pre>
<p>See code changes since the last commit</p>
<pre class="literal-block">
bzr diff
</pre>
<p>Commit changes</p>
<pre class="literal-block">
bzr commit -m &quot;Great new feature&quot;
</pre>
<p>Create a patch</p>
<pre class="literal-block">
bzr send -o great-new-feature.patch
</pre>
<p>See the
<a class="reference external" href="http://doc.bazaar-vcs.org/latest/en/tutorials/">Bazaar tutorials</a>
for more.</p>
<!-- vim: filetype=rst -->
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
Generated on: 2010-04-20.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
