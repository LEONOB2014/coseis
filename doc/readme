--------------------------------------------------------------------------------
SORD - Support Operator Rupture Dynamics
--------------------------------------------------------------------------------

  The Support Operator Rupture Dynamics code (SORD) models spontaneous rupture 
  on a fault within a 3D isotropic viscoelastic solid. The equations of motion 
  are approximated with a second order Support-Operator method on a logically 
  rectangular mesh. Grid cells are not required to be parallelepipeds, so that 
  non-rectangular meshes can be supported to model complex regions. However, 
  for areas in the mesh that are in fact rectangular, the computations are 
  equivalent to the finite difference method, and computations are streamlined 
  in that case. The fault itself is modeled using a double node technique, and 
  the rheology on the fault surface is modeled through a slip-weakening, 
  frictional, internal boundary condition. Optionally, the fault can be turned 
  off altogether and replaced by a moment tensor source. Model edge boundaries 
  can be reflective or absorbing, where absorbing boundaries are handled using 
  the perfectly matched layers method (PML). SORD is written in Fortran 95 and 
  parallelized using MPI for multi-processor execution.

AUTHOR

  Geoffrey Ely
  Institute of Geophysics and Planetary Physics
  Scripps Institution of Oceanography
  University of California, San Diego
  9500 Gilman Dr.
  La Jolla, CA 92093-0225
  gely@ucsd.edu


COORDINATE SYSTEM
 
  v---------v                   o----x----o         w----1----w
  |\         \                  |\         \        |\         \
  | .----.    \     l           | z----2    z       | 3----y    3
  | |\   |\    \     \          y |\   |\    \      2 |\    \    \
  | | v----.----v     0----j    | | o----x----o     | | w----1----w
  | '-|--w |    |     |         | 1-|--w |    |     | x |    |    |
  v  \|   \|    |     |         o  \|   \|    |     w  \|    |    |
   \  '----'    |     k          \  y----3    y      \  2----z    2
    \ |         |                 z |         |       3 |         |
     \|         |                  \|         |        \|         |
      v---------v                   o----x----o         w----1----w

  Non-staggered                 Staggered (1)       Staggered (2)
                               
  v: v = velocity               1 2 3: vx vy vz = velocity        
     u = displacement           x y z: wyz wzx wxy = shear stress 
     x = node locations             w: wxx wyy wzz = normal stress
     rho = density                     rho lam mu = material props
  w: w = stress                        x = node locations (2) 
     lam mu = elastic moduli        o: x = node locations (1) 


COMPUTATIONAL CYCLE
 
f_i = force vector
u_i = displacement vector
v_i = velocity vector
a_i = acceleration vector
w_ij = stress tensor
m_ij = moment tensor
rho = density
lam mu = elastic moduli
gamma = viscosity
dt = time step
 
Linearized conservation of momentum, Newton's 2nd law
  f_i = w_ij,j
  a_i = f_i/rho
  (hourglass corrections)
  (fault boundary condition)
  v_i' = a_i
  u_i' = v_i
Gradient
  g_ij = (u_i + gamma*v_i),j
Viscoelastic solid, Kelvin-Voight model, linear, isotropic,
spring and dashpot in parallel
  w_ij = lam*g_ij*delta_ij + mu*(g_ij+G_ji)
Moment tensor source
  w_ij = w_ij + dt*m_ij'

FAULT BOUNDARY CONDITION

n   = fault normal vector, n points toward the positive side of the fault
t   = traction exerted by the positive side
t0  = initial traction
wn0 = initial normal component of stress
r   = restoring force on a node
m   = nodal mass
s   = element area
f   = friction, |ts| cannot exceed friction

Acceleration and velocity of the double nodes due to restoring forces
and traction.

with no fault
a0 = a1 = (r0+r1)/(m0+m1)

- side acc   a0 = [r0 + s*(t-t0)]/m0	
+ side acc   a1 = [r1 - s*(t-t0)]/m1

- side vel   v0_ = v0 + dt*[r0 + s*(t-t0)]/m0
+ side vel   v1_ = v1 + dt*[r1 - s*(t-t0)]/m1

- side disp  u0_ = u0 + dt*{ v0(t0) + dt*[r0 + s*(t-t0)]/m0 }
+ side disp  u1_ = u1 + dt*{ v1(t0) + dt*[r1 - s*(t-t0)]/m1 }

da = a1 - a0
   = (r1/m1-r0/m0) - s*(1/m1+1/m0)*(t-t0)

dv = v1_ - v0_
   = v1-v0 + dt*da
   = v1-v0 + dt*(r1/m1-r0/m0) - dt*s*(1/m1+1/m0)*(t-t0)

du = u1_ - u0_
   = u1-u0 + dt*dv
   = u1-u0 + dt*(v1-v0) + dt^2*(r1/m1-r0/m0) - dt^2*s*(1/m1+1/m0)*(t-t0)

Zero relative acceleration boundary condition
da = 0
ta = t0 + (r1/m1-r0/m0) / [s*(1/m1+1/m0)]

Zero relative velocity boundary condition
dv = 0
tv = t0 + [v1-v0 + dt*(r1/m1-r0/m0)] / [dt*s*(1/m1+1/m0)]
   = ta + (v1-v0) / [dt*s*(1/m1+1/m0)]

Zero relative normal displacement boundary condition
du = 0
tu = t0 + [u1-u0 + dt*(v1-v0) + dt^2*(r1/m1-r0/m0)] / [dt^2*s*(1/m1+1/m0)]
   = tv + (u1-u0) / [dt^2*s*(1/m1+1/m0)]

Shear component of traction is bounded by friction
ts = tv.(I-nn)
ts~ = / ts,         |ts| <= f
      \ f*ts/|ts|,  |ts| >  f

Fault cannot open
tn = tv.n

Normal component of traction is bounded by cohesion (fault can open)
tn = tu.n
   = (tv + u1-u0).n / [dt^2*s*(1/m1+1/m0)]
tn~ = / tn,  tn <= co
      \ co,  tn >  co

Total traction bounded by friction
t~ = tn~.n + ts~

Update accelerations
a0_ = (r0 + s*(t~-t0))/m0
a1_ = (r1 - s*(t~-t0))/m1

Update velocities
v0_ = v0 + dt*(r0 + s*(t~-t0))/m0
v1_ = v1 + dt*(r1 - s*(t~-t0))/m1

DFM fault boundary condition
t = t0 + [r1*m0-r0*m1 + m1*m0*(v1-v0)/dt] / [s*(m1+m0)]


SLIP-WEAKENING FRICTION LAW

l     = slip length
mu(l) = coefficient of friction
mus   = coefficient of static friction
mud   = coefficient of dynamic friction
dc    = slip weakening distance

f = mu(l) * t.n + co
mu(l) = / mus - (us-ud)*l/dc,  l <= dc
        \ mud,                 l >  dc


      mus +
          |\
 ^ t0/wn0 + \
 |        |  \
 u    mud +   +---------
          |
          +---+---------
             dc   l->


Strength parameter
s = (tu - t0)/(t0 - tf)

Estimate critical radius needed for spontaneous rupture
rc =~ mu*dc*(tu - tf)/(t0 - tf)^2

Breakdown zone width
lc = dc*mu/(tu - tf)

Estimate dc needed to resolve breakdown zone
dc =~ (3 or 4)*dx*(tu - tf)/mu

Strain energy change
e_strain = int_a su_i * ( t0_i + t_i ) / 2 * da

Friction energy
e_fric = int_t int_a sv_i * t_i * da * dt

Moment
m0 = int_a * su_i * mu * da

Moment magnitude
mw = ( log10( m0 ) - 9.05 ) / 1.5

Ratiated energy
e_radiate = e_strain - e_fric

PRETRACTION

  u = upward pointing unit normal

  Consider either of the two fault walls:
  n = local surface normal, points towards the oposing fault wall
  h = n x u, horizontal unit normal (strike), points to the right on
             the near wall, left on the far wall.
  d = n x h, dip unit normal, for a vertical fault d = -u

       .------------ 
      /  n u       /
     /    \|      /
    /   h--+     /
   /      /     /
  /      d     /
  ------------'

  Pre-traction:
  t0 = tn*n + th*h + td*d
  tn < 0 compresive traction
  tn > 0 opening traction
  th > 0 right-lateral slip
  th < 0 left-lateral slip

  When t0 is applied to the near wall, and -t0 applied to the far wall:
  td > 0 far side moves down (is there a name for this?)
  td < 0 far side moves up

KOSTROV SOLUTION

Kostrov, 1964
Day, 1982, p 717

Circular crack expanding at a uniform rupture velocity

vslip = H(T) * C * dtau / mu * vs * (T + r/vrup) / sqrt(T * (T + 2*r/vrup))

T    = reduced time t - r/vrup
H    = unit step function
C    = .81   for nu = .25 and vrup = .9*vs (Dahlen, 1974)
dtau = stress drop
mu   = rho * vs^2
vrup = 0.9 * vs



HOURGLASS CORRECTIONS

One of the first works in this direction was presented by Kosloff and Frazier
(1978), but in their formulation it is necessary to solve 4 systems of 8
equations for distorted three-dimensional elements, and this is not cost
efficient for dynamic analysis.  Flanagan and Belytschko (1981), Belytschko
(1983), and Belytschko, Ong, Liu and Kennedy (1984) presented a systematic and
effective way to hourglass control, but in both formulations a parameter, to be
defined by the user, is required.  Belytschko and Binderman (1993) implemented
the hourglass control of the eight-node hexahedral element, where the
stabilization parameter is not required, although the stabilization matrix
still depends on the Poisson coefficient; the aspect was eliminated by Liu, Hu
and Belytschko (1994).

Kosloff, Frazier, 1978
Flanagan, and Belytschko, 1981 ***
Belytschko, 1983
Belytschko, Ong, Liu, Keneddy, 1984
Belytschko, Binderman, 1993 ***
Liu, Hu, Belytschko, 1994


Deformation Modes for hexahedron: 8 * 3 = 24 degrees of freedom

Rigid Body: 6 = 3 translation + 3 rotation

Uniform strain: 6

  l           .----O      .----.      0----0
   \          |\   |\     |\   |\     |\   |\
    0----j    | .----O    | .----.    | .----.
    |         '-|--O |    0-|--0 |    O-|--O |
    |          \|   \|     \|   \|     \|   \|
    k           '----O      O----O      '----'
                 Z1          Z2          Z3

Nonuniform strain: 12 = 24 DOF - 6 rigid body - 6 uniform strain

  0----0      0----.      .----0      .----0
  |\   |\     |\   |\     |\   |\     |\    \ 
  | .----.    | .----0    | .----0    | 0----.  
  '-|--' |    0-|--' |    0-|--' |    0-|--' |
   \|   \|     \|   \|     \|   \|     \|   \|
    0----0      '----0      0----'      '----0  
    Z2 Z3       Z3 Z1       Z1 Z2     Z1 Z2 Z3

Sum on a point

  C---------C
  |\         \
  | .----B    \     A = -32
  | |\   |\    \    B = +8
  | | C----.----C   C = -2
  | B-|--A |    |
  C  \|   \|    |
   \  '----B    |
    \ |         |
     \|         |
      C---------C

Y = mu*(lam+mu)/6/(lam+2*mu)

q = Y*du*dx^2*dy^2/dv^2
a = dQ/dv/rho

q = Y*du*/h^2
a = dQ/h^3/rho



MOMENT SOURCE

del^2*phi - phi'' / vp^2  =  -4*pi*delta(r) * f(t)
phi  =  -f(t-r/vp) / r
u    =  del*phi   =  f(t-r/vp)  / r^2  +  f'(t-r/vp)  / r/vp
v    =  del*phi'  =  f'(t-r/vp) / r^2  +  f''(t-r/vp) / r/vp
M    =  -4 * pi * rho * vp^2 * f

Brune Source
M   = -H * M0 * e^(-t/T) / T   * (t + T) + M0
M'  =  H * M0 * e^(-t/T) / T^2 *  t
M'' = -H * M0 * e^(-t/T) / T^3 * (t - T)

       H * M0 * e^(-t/T) * ( t*vp/r - t/T + 1 )
v   =  ----------------------------------------
       4 * pi * rho * vp^2 * T^2 * r * vp

Analytical Inverse
Divide 1 by the Laplace transform of the Brune pulse, then in this result,
interpret the Laplace variable as a differentiation operator. The result is
(d/dt + 1/T)^2. 

So to simultaneously deconvolve the Brune pulse  from a series, and then
convolve with a newly desired source function S, you just apply the operator
(d/dt + 1/T)^2 to S, which just gives you d/dt(dS/dt) + 2(dS/dt)/T + S/T^2,
and then convolve this result with the original series.

Smooth Brune
M   = -H * M0 * e^(-t/t) / T^2 / 2 * (t^2 + 2*t*T + 2*T^2) + M0
M'  =  H * M0 * e^(-t/t) / T^3 / 2 *  t^2
M'' = -H * M0 * e^(-t/t) / T^4 / 2 * (t^2 - 2*t*T)

       H * M0 * e^(-t/T) * ( t*vp/r - t/T + 2 ) * t
v   =  ----------------------------------------
       8 * pi * rho * vp^2 * T^3 * r * vp


PML ABSORBING BOUNDARY CONDITION

Stress-Velocity
g_ij = v_i,j
w_ij' = lam*delta_ij*g_kk + mu*(g_ij + g_ji)
f_i = w_ij,j
v_i' = f_i/rho

Stress-Velocity with PML
g_ij = v_i,j
w_ij' = lam*delta_ij*g_kk + mu*(g_ij + g_ji)
f_i = w_ij,j
v_i' = f_i/rho

SORD
g_ij = (u_i + gamma*v_i),j
w_ij = lam*delta_ij*g_kk + mu*(g_ij + g_ji)
f_i = w_ij,j + hourglass
v_i' = f_i/rho
u_i' = v_i

SORD with PML (no summation convetion)
if d_j == 0
  g_ij = u_i,j
else
  g'_ij + d_j*g_ij = v_i,j
end
w_ij = lam*delta_ij*g_kk + mu*(g_ij + g_ji)
p'_ij + d_j*p_ij = w_ij,j
f_i = sum_j(p'_ij)
f_i = f_i + hourglass
v_i' = f_i/rho
u_i' = v_i

PML Discretization
(g2 - g1)/dt  + d*(g2 + g1)/2 = v_i,j
g2 = (2 - d*dt)/(2 + d*dt)*g1 + 2*dt/(2 + d*dt)*v_i,j
w  = c:g2
(p2 - p1)/dt   + d*(p2 + p1)/2 = w_ij,j
(p2 - p1)/dt*2 + d*(p2 + p1)   = 2*w_ij,j
(p2 - p1)/dt*(2 + d*dt) + 2*d*p1 = 2*w_ij,j
(p2 - p1)/dt = -2*d/(2 + d*dt)*p1 + 2/(2 + d*dt)*w_ij,j
v2 = v1 + (p2 - p1)/dt/rho
u2 = u1 + v * dt

nb  = PML thickness (in nodes)
i   = node index counted from the PML interface
d   = d0 * (i/nb)^2
d0  = t*vs0/h*( c1 + c2*nb + c3*nb^2 )
t   = 3.5
vs0 = 2 / ( 1/max(vs) + 1/min(vs) )
c1  =  8/15
c2  = -3/100
c3  =  1/1500


ELASTIC MODULI

  Vs = sqrt( mu / rho )
  Vp = sqrt( ( lam + 2 * mu ) / rho )

  Shear modulus
  mu = rho * vs^2

  Lame's 2nd parameter
  lam = rho * ( vp^2 - 2*vs^2 )

  Bulk modulus
  kappa = lam + 2/3*mu

  Poisson's ratio
  nu = .5 * lam / ( lam + mu )
  nu = .5 * (vp^2 - 2*vs^2) / (vp^2 - vs^2)
  nu =  0          fluid
  nu = .25 to .3   crustal rocks
  nu = .25         Poisson solid vp/vs = sqrt(3)

COURANT STABILITY CONDITION

  dt * vp * sqrt(3) / dx   >    1



DOMAIN DECOMPOSITION DIAGRAM

                          .---. 1     
  Surface                 |   |
  ------- o---o 1         o---o i1node
          | o | 1         | o | i1cell
          o---o           o---o
          | o |           | o |
          o---o           o---o i2node   .---. 1     
    PML   | o |           | o | i2cell   | o | i1cell
          o---o           '---' nm=5     o---o i1node
          | o |                          | o |
          o---o i1pml                    o---o
  ------- | o | i1pml                    | o |
          x---x i1pml+1   .---. 1        x---x i2node
  Elastic |[x]| i1pml+1   |[x]| i1cell   |[x]| i2cell
          x---x           x---x i1node   '---' nm=5
          |[x]|           |[x]|
  Fault-> xx-xx           xx-xx i2node   .---. 1
          |[x]|           |[x]| i2cell   |[x]| i1cell
          x---x           '---' nm=5     x---x i1node
  Elastic |[x]| i2pml-2                  | o |
          x---x i2pml-1                  o---o
  ------- | o | i2pml-1                  | o |
          o---o i2pml     .---. 1        o---o i2node
          | o |           | o | i1cell   | o | i2cell
          o---o           o---o i1node   '---' nm
    PML   | o |           | o |
          o---o           o---o
          | o |           | o |
          o---o           o---o i2node   .---. 1
          | o | 15        | o | i2cell   | o | i1cell i2cell
  ------- o---o nn=16     '---' nm=5     o---o i1node i2node
  Surface       n=15                     |   |
                                         '---' nm=3


REYNOLDS GLYPH

r = w_ij*n_i*n_j

Vector

r = v^p * |cos(f)|^p
x = r * [ sin(f) * cos(t)
          sin(f) * sin(t)
          cos(f) ]
n = [ (p+1) * sin(f)^2 * cos(t)
      (p+1) * sin(f)^2 * sin(t)
      sin(f) / |cos(f)| * ( cos(f)^2 - p*sin(f)^2 ) ]


SOM

